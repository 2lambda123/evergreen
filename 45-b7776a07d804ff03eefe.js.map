{"version":3,"sources":["webpack:///./node_modules/core-js/modules/es6.function.name.js","webpack:///./node_modules/core-js/modules/es6.string.trim.js","webpack:///./node_modules/core-js/modules/es6.regexp.search.js","webpack:///./node_modules/fuzzaldrin-plus/lib/scorer.js","webpack:///./node_modules/fuzzaldrin-plus/lib/pathScorer.js","webpack:///./node_modules/fuzzaldrin-plus/lib/query.js","webpack:///./node_modules/core-js/modules/_string-trim.js","webpack:///./node_modules/process/browser.js","webpack:///./node_modules/core-js/modules/_string-ws.js","webpack:///./node_modules/fuzzaldrin-plus/lib/fuzzaldrin.js","webpack:///./node_modules/fuzzaldrin-plus/lib/filter.js","webpack:///./node_modules/fuzzaldrin-plus/lib/matcher.js"],"names":["dP","__webpack_require__","f","FProto","Function","prototype","nameRE","configurable","get","this","match","e","327","r","n","t","$trim","407","defined","SEARCH","$search","regexp","O","fn","call","RegExp","String","AcronymResult","computeScore","emptyAcronymResult","isAcronymFullWord","isMatch","isSeparator","isWordEnd","isWordStart","scoreAcronyms","scoreCharacter","scoreConsecutives","scoreExact","scoreExactMatch","scorePattern","scorePosition","scoreSize","exports","score","string","query","options","preparedQuery","string_lw","allowErrors","core_lw","core_up","toLowerCase","Math","ceil","subject","query_lw","query_up","i","j","m","qj_lw","qj_up","si","length","charCodeAt","subject_lw","acro","acro_score","align","csc_diag","csc_row","csc_score","csc_should_rebuild","miss_budget","miss_left","pos","record_miss","score_diag","score_row","score_up","si_lw","start","sz","count","indexOf","Array","charCodes","max","curr_s","prev_s","len","next_s","c","sc","abs","quality","sameCase","end","bonus","posBonus","startOfWord","k","mi","nj","pos2","fullWord","sepCount","sumPos","nbAcronymInQuery","countDir","getExtensionScore","scorePath","_ref","fullPathScore","alpha","basePathScore","basePos","depth","extAdjust","fileLength","pathSeparator","useExtensionBonus","lastIndexOf","ext","slice","path","getExtension","str","substr","candidate","startPos","endPos","maxDepth","matched","coreChars","getCharCodes","opt_char_re","truncatedUpperCase","module","_arg","optCharRegEx","_ref1","core","replace","upper","_i","_len","toUpperCase","$export","fails","spaces","space","ltrim","rtrim","exporter","KEY","exec","ALIAS","exp","FORCE","trim","P","F","TYPE","cachedSetTimeout","cachedClearTimeout","process","defaultSetTimout","Error","defaultClearTimeout","runTimeout","fun","setTimeout","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","concat","drainQueue","timeout","run","marker","Item","array","noop","nextTick","args","arguments","push","apply","title","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","name","binding","cwd","chdir","dir","umask","431","432","Query","defaultPathSeparator","filter","matcher","parseOptions","pathScorer","preparedQueryCache","scorer","platform","candidates","usePathScoring","_results","wrap","prepareQuery","pluckCandidates","sortCandidates","a","b","bKey","key","maxInners","maxResults","scoreProvider","scoredCandidates","spotLeft","sort","map","basenameMatch","computeMatch","mergeMatches","baseMatches","matches","matchIndex","matchPos","matchPositions","output","strPos","tagClass","tagClose","tagOpen","substring","ai","bj","out","offset","backtrack","move","trace","reverse"],"mappings":"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","file":"45-b7776a07d804ff03eefe.js","sourcesContent":["var dP = require('./_object-dp').f;\nvar FProto = Function.prototype;\nvar nameRE = /^\\s*function ([^ (]*)/;\nvar NAME = 'name';\n\n// 19.2.4.2 name\nNAME in FProto || require('./_descriptors') && dP(FProto, NAME, {\n  configurable: true,\n  get: function () {\n    try {\n      return ('' + this).match(nameRE)[1];\n    } catch (e) {\n      return '';\n    }\n  }\n});\n","'use strict';\n// 21.1.3.25 String.prototype.trim()\nrequire('./_string-trim')('trim', function ($trim) {\n  return function trim() {\n    return $trim(this, 3);\n  };\n});\n","// @@search logic\nrequire('./_fix-re-wks')('search', 1, function (defined, SEARCH, $search) {\n  // 21.1.3.15 String.prototype.search(regexp)\n  return [function search(regexp) {\n    'use strict';\n    var O = defined(this);\n    var fn = regexp == undefined ? undefined : regexp[SEARCH];\n    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));\n  }, $search];\n});\n","(function() {\n  var AcronymResult, computeScore, emptyAcronymResult, isAcronymFullWord, isMatch, isSeparator, isWordEnd, isWordStart, miss_coeff, pos_bonus, scoreAcronyms, scoreCharacter, scoreConsecutives, scoreExact, scoreExactMatch, scorePattern, scorePosition, scoreSize, tau_size, wm;\n\n  wm = 150;\n\n  pos_bonus = 20;\n\n  tau_size = 150;\n\n  miss_coeff = 0.75;\n\n  exports.score = function(string, query, options) {\n    var allowErrors, preparedQuery, score, string_lw;\n    preparedQuery = options.preparedQuery, allowErrors = options.allowErrors;\n    if (!(allowErrors || isMatch(string, preparedQuery.core_lw, preparedQuery.core_up))) {\n      return 0;\n    }\n    string_lw = string.toLowerCase();\n    score = computeScore(string, string_lw, preparedQuery);\n    return Math.ceil(score);\n  };\n\n  exports.isMatch = isMatch = function(subject, query_lw, query_up) {\n    var i, j, m, n, qj_lw, qj_up, si;\n    m = subject.length;\n    n = query_lw.length;\n    if (!m || n > m) {\n      return false;\n    }\n    i = -1;\n    j = -1;\n    while (++j < n) {\n      qj_lw = query_lw.charCodeAt(j);\n      qj_up = query_up.charCodeAt(j);\n      while (++i < m) {\n        si = subject.charCodeAt(i);\n        if (si === qj_lw || si === qj_up) {\n          break;\n        }\n      }\n      if (i === m) {\n        return false;\n      }\n    }\n    return true;\n  };\n\n  exports.computeScore = computeScore = function(subject, subject_lw, preparedQuery) {\n    var acro, acro_score, align, csc_diag, csc_row, csc_score, csc_should_rebuild, i, j, m, miss_budget, miss_left, n, pos, query, query_lw, record_miss, score, score_diag, score_row, score_up, si_lw, start, sz;\n    query = preparedQuery.query;\n    query_lw = preparedQuery.query_lw;\n    m = subject.length;\n    n = query.length;\n    acro = scoreAcronyms(subject, subject_lw, query, query_lw);\n    acro_score = acro.score;\n    if (acro.count === n) {\n      return scoreExact(n, m, acro_score, acro.pos);\n    }\n    pos = subject_lw.indexOf(query_lw);\n    if (pos > -1) {\n      return scoreExactMatch(subject, subject_lw, query, query_lw, pos, n, m);\n    }\n    score_row = new Array(n);\n    csc_row = new Array(n);\n    sz = scoreSize(n, m);\n    miss_budget = Math.ceil(miss_coeff * n) + 5;\n    miss_left = miss_budget;\n    csc_should_rebuild = true;\n    j = -1;\n    while (++j < n) {\n      score_row[j] = 0;\n      csc_row[j] = 0;\n    }\n    i = -1;\n    while (++i < m) {\n      si_lw = subject_lw[i];\n      if (!si_lw.charCodeAt(0) in preparedQuery.charCodes) {\n        if (csc_should_rebuild) {\n          j = -1;\n          while (++j < n) {\n            csc_row[j] = 0;\n          }\n          csc_should_rebuild = false;\n        }\n        continue;\n      }\n      score = 0;\n      score_diag = 0;\n      csc_diag = 0;\n      record_miss = true;\n      csc_should_rebuild = true;\n      j = -1;\n      while (++j < n) {\n        score_up = score_row[j];\n        if (score_up > score) {\n          score = score_up;\n        }\n        csc_score = 0;\n        if (query_lw[j] === si_lw) {\n          start = isWordStart(i, subject, subject_lw);\n          csc_score = csc_diag > 0 ? csc_diag : scoreConsecutives(subject, subject_lw, query, query_lw, i, j, start);\n          align = score_diag + scoreCharacter(i, j, start, acro_score, csc_score);\n          if (align > score) {\n            score = align;\n            miss_left = miss_budget;\n          } else {\n            if (record_miss && --miss_left <= 0) {\n              return Math.max(score, score_row[n - 1]) * sz;\n            }\n            record_miss = false;\n          }\n        }\n        score_diag = score_up;\n        csc_diag = csc_row[j];\n        csc_row[j] = csc_score;\n        score_row[j] = score;\n      }\n    }\n    score = score_row[n - 1];\n    return score * sz;\n  };\n\n  exports.isWordStart = isWordStart = function(pos, subject, subject_lw) {\n    var curr_s, prev_s;\n    if (pos === 0) {\n      return true;\n    }\n    curr_s = subject[pos];\n    prev_s = subject[pos - 1];\n    return isSeparator(prev_s) || (curr_s !== subject_lw[pos] && prev_s === subject_lw[pos - 1]);\n  };\n\n  exports.isWordEnd = isWordEnd = function(pos, subject, subject_lw, len) {\n    var curr_s, next_s;\n    if (pos === len - 1) {\n      return true;\n    }\n    curr_s = subject[pos];\n    next_s = subject[pos + 1];\n    return isSeparator(next_s) || (curr_s === subject_lw[pos] && next_s !== subject_lw[pos + 1]);\n  };\n\n  isSeparator = function(c) {\n    return c === ' ' || c === '.' || c === '-' || c === '_' || c === '/' || c === '\\\\';\n  };\n\n  scorePosition = function(pos) {\n    var sc;\n    if (pos < pos_bonus) {\n      sc = pos_bonus - pos;\n      return 100 + sc * sc;\n    } else {\n      return Math.max(100 + pos_bonus - pos, 0);\n    }\n  };\n\n  exports.scoreSize = scoreSize = function(n, m) {\n    return tau_size / (tau_size + Math.abs(m - n));\n  };\n\n  scoreExact = function(n, m, quality, pos) {\n    return 2 * n * (wm * quality + scorePosition(pos)) * scoreSize(n, m);\n  };\n\n  exports.scorePattern = scorePattern = function(count, len, sameCase, start, end) {\n    var bonus, sz;\n    sz = count;\n    bonus = 6;\n    if (sameCase === count) {\n      bonus += 2;\n    }\n    if (start) {\n      bonus += 3;\n    }\n    if (end) {\n      bonus += 1;\n    }\n    if (count === len) {\n      if (start) {\n        if (sameCase === len) {\n          sz += 2;\n        } else {\n          sz += 1;\n        }\n      }\n      if (end) {\n        bonus += 1;\n      }\n    }\n    return sameCase + sz * (sz + bonus);\n  };\n\n  exports.scoreCharacter = scoreCharacter = function(i, j, start, acro_score, csc_score) {\n    var posBonus;\n    posBonus = scorePosition(i);\n    if (start) {\n      return posBonus + wm * ((acro_score > csc_score ? acro_score : csc_score) + 10);\n    }\n    return posBonus + wm * csc_score;\n  };\n\n  exports.scoreConsecutives = scoreConsecutives = function(subject, subject_lw, query, query_lw, i, j, startOfWord) {\n    var k, m, mi, n, nj, sameCase, sz;\n    m = subject.length;\n    n = query.length;\n    mi = m - i;\n    nj = n - j;\n    k = mi < nj ? mi : nj;\n    sameCase = 0;\n    sz = 0;\n    if (query[j] === subject[i]) {\n      sameCase++;\n    }\n    while (++sz < k && query_lw[++j] === subject_lw[++i]) {\n      if (query[j] === subject[i]) {\n        sameCase++;\n      }\n    }\n    if (sz < k) {\n      i--;\n    }\n    if (sz === 1) {\n      return 1 + 2 * sameCase;\n    }\n    return scorePattern(sz, n, sameCase, startOfWord, isWordEnd(i, subject, subject_lw, m));\n  };\n\n  exports.scoreExactMatch = scoreExactMatch = function(subject, subject_lw, query, query_lw, pos, n, m) {\n    var end, i, pos2, sameCase, start;\n    start = isWordStart(pos, subject, subject_lw);\n    if (!start) {\n      pos2 = subject_lw.indexOf(query_lw, pos + 1);\n      if (pos2 > -1) {\n        start = isWordStart(pos2, subject, subject_lw);\n        if (start) {\n          pos = pos2;\n        }\n      }\n    }\n    i = -1;\n    sameCase = 0;\n    while (++i < n) {\n      if (query[pos + i] === subject[i]) {\n        sameCase++;\n      }\n    }\n    end = isWordEnd(pos + n - 1, subject, subject_lw, m);\n    return scoreExact(n, m, scorePattern(n, n, sameCase, start, end), pos);\n  };\n\n  AcronymResult = (function() {\n    function AcronymResult(score, pos, count) {\n      this.score = score;\n      this.pos = pos;\n      this.count = count;\n    }\n\n    return AcronymResult;\n\n  })();\n\n  emptyAcronymResult = new AcronymResult(0, 0.1, 0);\n\n  exports.scoreAcronyms = scoreAcronyms = function(subject, subject_lw, query, query_lw) {\n    var count, fullWord, i, j, m, n, qj_lw, sameCase, score, sepCount, sumPos;\n    m = subject.length;\n    n = query.length;\n    if (!(m > 1 && n > 1)) {\n      return emptyAcronymResult;\n    }\n    count = 0;\n    sepCount = 0;\n    sumPos = 0;\n    sameCase = 0;\n    i = -1;\n    j = -1;\n    while (++j < n) {\n      qj_lw = query_lw[j];\n      if (isSeparator(qj_lw)) {\n        i = subject_lw.indexOf(qj_lw, i + 1);\n        if (i > -1) {\n          sepCount++;\n          continue;\n        } else {\n          break;\n        }\n      }\n      while (++i < m) {\n        if (qj_lw === subject_lw[i] && isWordStart(i, subject, subject_lw)) {\n          if (query[j] === subject[i]) {\n            sameCase++;\n          }\n          sumPos += i;\n          count++;\n          break;\n        }\n      }\n      if (i === m) {\n        break;\n      }\n    }\n    if (count < 2) {\n      return emptyAcronymResult;\n    }\n    fullWord = count === n ? isAcronymFullWord(subject, subject_lw, query, count) : false;\n    score = scorePattern(count, n, sameCase, true, fullWord);\n    return new AcronymResult(score, sumPos / count, count + sepCount);\n  };\n\n  isAcronymFullWord = function(subject, subject_lw, query, nbAcronymInQuery) {\n    var count, i, m, n;\n    m = subject.length;\n    n = query.length;\n    count = 0;\n    if (m > 12 * n) {\n      return false;\n    }\n    i = -1;\n    while (++i < m) {\n      if (isWordStart(i, subject, subject_lw) && ++count > nbAcronymInQuery) {\n        return false;\n      }\n    }\n    return true;\n  };\n\n}).call(this);\n","(function() {\n  var computeScore, countDir, file_coeff, getExtension, getExtensionScore, isMatch, scorePath, scoreSize, tau_depth, _ref;\n\n  _ref = require('./scorer'), isMatch = _ref.isMatch, computeScore = _ref.computeScore, scoreSize = _ref.scoreSize;\n\n  tau_depth = 20;\n\n  file_coeff = 2.5;\n\n  exports.score = function(string, query, options) {\n    var allowErrors, preparedQuery, score, string_lw;\n    preparedQuery = options.preparedQuery, allowErrors = options.allowErrors;\n    if (!(allowErrors || isMatch(string, preparedQuery.core_lw, preparedQuery.core_up))) {\n      return 0;\n    }\n    string_lw = string.toLowerCase();\n    score = computeScore(string, string_lw, preparedQuery);\n    score = scorePath(string, string_lw, score, options);\n    return Math.ceil(score);\n  };\n\n  scorePath = function(subject, subject_lw, fullPathScore, options) {\n    var alpha, basePathScore, basePos, depth, end, extAdjust, fileLength, pathSeparator, preparedQuery, useExtensionBonus;\n    if (fullPathScore === 0) {\n      return 0;\n    }\n    preparedQuery = options.preparedQuery, useExtensionBonus = options.useExtensionBonus, pathSeparator = options.pathSeparator;\n    end = subject.length - 1;\n    while (subject[end] === pathSeparator) {\n      end--;\n    }\n    basePos = subject.lastIndexOf(pathSeparator, end);\n    fileLength = end - basePos;\n    extAdjust = 1.0;\n    if (useExtensionBonus) {\n      extAdjust += getExtensionScore(subject_lw, preparedQuery.ext, basePos, end, 2);\n      fullPathScore *= extAdjust;\n    }\n    if (basePos === -1) {\n      return fullPathScore;\n    }\n    depth = preparedQuery.depth;\n    while (basePos > -1 && depth-- > 0) {\n      basePos = subject.lastIndexOf(pathSeparator, basePos - 1);\n    }\n    basePathScore = basePos === -1 ? fullPathScore : extAdjust * computeScore(subject.slice(basePos + 1, end + 1), subject_lw.slice(basePos + 1, end + 1), preparedQuery);\n    alpha = 0.5 * tau_depth / (tau_depth + countDir(subject, end + 1, pathSeparator));\n    return alpha * basePathScore + (1 - alpha) * fullPathScore * scoreSize(0, file_coeff * fileLength);\n  };\n\n  exports.countDir = countDir = function(path, end, pathSeparator) {\n    var count, i;\n    if (end < 1) {\n      return 0;\n    }\n    count = 0;\n    i = -1;\n    while (++i < end && path[i] === pathSeparator) {\n      continue;\n    }\n    while (++i < end) {\n      if (path[i] === pathSeparator) {\n        count++;\n        while (++i < end && path[i] === pathSeparator) {\n          continue;\n        }\n      }\n    }\n    return count;\n  };\n\n  exports.getExtension = getExtension = function(str) {\n    var pos;\n    pos = str.lastIndexOf(\".\");\n    if (pos < 0) {\n      return \"\";\n    } else {\n      return str.substr(pos + 1);\n    }\n  };\n\n  getExtensionScore = function(candidate, ext, startPos, endPos, maxDepth) {\n    var m, matched, n, pos;\n    if (!ext.length) {\n      return 0;\n    }\n    pos = candidate.lastIndexOf(\".\", endPos);\n    if (!(pos > startPos)) {\n      return 0;\n    }\n    n = ext.length;\n    m = endPos - pos;\n    if (m < n) {\n      n = m;\n      m = ext.length;\n    }\n    pos++;\n    matched = -1;\n    while (++matched < n) {\n      if (candidate[pos + matched] !== ext[matched]) {\n        break;\n      }\n    }\n    if (matched === 0 && maxDepth > 0) {\n      return 0.9 * getExtensionScore(candidate, ext, startPos, pos - 2, maxDepth - 1);\n    }\n    return matched / m;\n  };\n\n}).call(this);\n","(function() {\n  var Query, coreChars, countDir, getCharCodes, getExtension, opt_char_re, truncatedUpperCase, _ref;\n\n  _ref = require(\"./pathScorer\"), countDir = _ref.countDir, getExtension = _ref.getExtension;\n\n  module.exports = Query = (function() {\n    function Query(query, _arg) {\n      var optCharRegEx, pathSeparator, _ref1;\n      _ref1 = _arg != null ? _arg : {}, optCharRegEx = _ref1.optCharRegEx, pathSeparator = _ref1.pathSeparator;\n      if (!(query && query.length)) {\n        return null;\n      }\n      this.query = query;\n      this.query_lw = query.toLowerCase();\n      this.core = coreChars(query, optCharRegEx);\n      this.core_lw = this.core.toLowerCase();\n      this.core_up = truncatedUpperCase(this.core);\n      this.depth = countDir(query, query.length, pathSeparator);\n      this.ext = getExtension(this.query_lw);\n      this.charCodes = getCharCodes(this.query_lw);\n    }\n\n    return Query;\n\n  })();\n\n  opt_char_re = /[ _\\-:\\/\\\\]/g;\n\n  coreChars = function(query, optCharRegEx) {\n    if (optCharRegEx == null) {\n      optCharRegEx = opt_char_re;\n    }\n    return query.replace(optCharRegEx, '');\n  };\n\n  truncatedUpperCase = function(str) {\n    var char, upper, _i, _len;\n    upper = \"\";\n    for (_i = 0, _len = str.length; _i < _len; _i++) {\n      char = str[_i];\n      upper += char.toUpperCase()[0];\n    }\n    return upper;\n  };\n\n  getCharCodes = function(str) {\n    var charCodes, i, len;\n    len = str.length;\n    i = -1;\n    charCodes = [];\n    while (++i < len) {\n      charCodes[str.charCodeAt(i)] = true;\n    }\n    return charCodes;\n  };\n\n}).call(this);\n","var $export = require('./_export');\nvar defined = require('./_defined');\nvar fails = require('./_fails');\nvar spaces = require('./_string-ws');\nvar space = '[' + spaces + ']';\nvar non = '\\u200b\\u0085';\nvar ltrim = RegExp('^' + space + space + '*');\nvar rtrim = RegExp(space + space + '*$');\n\nvar exporter = function (KEY, exec, ALIAS) {\n  var exp = {};\n  var FORCE = fails(function () {\n    return !!spaces[KEY]() || non[KEY]() != non;\n  });\n  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];\n  if (ALIAS) exp[ALIAS] = fn;\n  $export($export.P + $export.F * FORCE, 'String', exp);\n};\n\n// 1 -> String#trimLeft\n// 2 -> String#trimRight\n// 3 -> String#trim\nvar trim = exporter.trim = function (string, TYPE) {\n  string = String(defined(string));\n  if (TYPE & 1) string = string.replace(ltrim, '');\n  if (TYPE & 2) string = string.replace(rtrim, '');\n  return string;\n};\n\nmodule.exports = exporter;\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","module.exports = '\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003' +\n  '\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF';\n","(function() {\n  var Query, defaultPathSeparator, filter, matcher, parseOptions, pathScorer, preparedQueryCache, scorer;\n\n  filter = require('./filter');\n\n  matcher = require('./matcher');\n\n  scorer = require('./scorer');\n\n  pathScorer = require('./pathScorer');\n\n  Query = require('./query');\n\n  preparedQueryCache = null;\n\n  defaultPathSeparator = (typeof process !== \"undefined\" && process !== null ? process.platform : void 0) === \"win32\" ? '\\\\' : '/';\n\n  module.exports = {\n    filter: function(candidates, query, options) {\n      if (options == null) {\n        options = {};\n      }\n      if (!((query != null ? query.length : void 0) && (candidates != null ? candidates.length : void 0))) {\n        return [];\n      }\n      options = parseOptions(options, query);\n      return filter(candidates, query, options);\n    },\n    score: function(string, query, options) {\n      if (options == null) {\n        options = {};\n      }\n      if (!((string != null ? string.length : void 0) && (query != null ? query.length : void 0))) {\n        return 0;\n      }\n      options = parseOptions(options, query);\n      if (options.usePathScoring) {\n        return pathScorer.score(string, query, options);\n      } else {\n        return scorer.score(string, query, options);\n      }\n    },\n    match: function(string, query, options) {\n      var _i, _ref, _results;\n      if (options == null) {\n        options = {};\n      }\n      if (!string) {\n        return [];\n      }\n      if (!query) {\n        return [];\n      }\n      if (string === query) {\n        return (function() {\n          _results = [];\n          for (var _i = 0, _ref = string.length; 0 <= _ref ? _i < _ref : _i > _ref; 0 <= _ref ? _i++ : _i--){ _results.push(_i); }\n          return _results;\n        }).apply(this);\n      }\n      options = parseOptions(options, query);\n      return matcher.match(string, query, options);\n    },\n    wrap: function(string, query, options) {\n      if (options == null) {\n        options = {};\n      }\n      if (!string) {\n        return [];\n      }\n      if (!query) {\n        return [];\n      }\n      options = parseOptions(options, query);\n      return matcher.wrap(string, query, options);\n    },\n    prepareQuery: function(query, options) {\n      if (options == null) {\n        options = {};\n      }\n      options = parseOptions(options, query);\n      return options.preparedQuery;\n    }\n  };\n\n  parseOptions = function(options, query) {\n    if (options.allowErrors == null) {\n      options.allowErrors = false;\n    }\n    if (options.usePathScoring == null) {\n      options.usePathScoring = true;\n    }\n    if (options.useExtensionBonus == null) {\n      options.useExtensionBonus = false;\n    }\n    if (options.pathSeparator == null) {\n      options.pathSeparator = defaultPathSeparator;\n    }\n    if (options.optCharRegEx == null) {\n      options.optCharRegEx = null;\n    }\n    if (options.wrap == null) {\n      options.wrap = null;\n    }\n    if (options.preparedQuery == null) {\n      options.preparedQuery = preparedQueryCache && preparedQueryCache.query === query ? preparedQueryCache : (preparedQueryCache = new Query(query, options));\n    }\n    return options;\n  };\n\n}).call(this);\n","(function() {\n  var Query, pathScorer, pluckCandidates, scorer, sortCandidates;\n\n  scorer = require('./scorer');\n\n  pathScorer = require('./pathScorer');\n\n  Query = require('./query');\n\n  pluckCandidates = function(a) {\n    return a.candidate;\n  };\n\n  sortCandidates = function(a, b) {\n    return b.score - a.score;\n  };\n\n  module.exports = function(candidates, query, options) {\n    var bKey, candidate, key, maxInners, maxResults, score, scoreProvider, scoredCandidates, spotLeft, string, usePathScoring, _i, _len;\n    scoredCandidates = [];\n    key = options.key, maxResults = options.maxResults, maxInners = options.maxInners, usePathScoring = options.usePathScoring;\n    spotLeft = (maxInners != null) && maxInners > 0 ? maxInners : candidates.length + 1;\n    bKey = key != null;\n    scoreProvider = usePathScoring ? pathScorer : scorer;\n    for (_i = 0, _len = candidates.length; _i < _len; _i++) {\n      candidate = candidates[_i];\n      string = bKey ? candidate[key] : candidate;\n      if (!string) {\n        continue;\n      }\n      score = scoreProvider.score(string, query, options);\n      if (score > 0) {\n        scoredCandidates.push({\n          candidate: candidate,\n          score: score\n        });\n        if (!--spotLeft) {\n          break;\n        }\n      }\n    }\n    scoredCandidates.sort(sortCandidates);\n    candidates = scoredCandidates.map(pluckCandidates);\n    if (maxResults != null) {\n      candidates = candidates.slice(0, maxResults);\n    }\n    return candidates;\n  };\n\n}).call(this);\n","(function() {\n  var basenameMatch, computeMatch, isMatch, isWordStart, match, mergeMatches, scoreAcronyms, scoreCharacter, scoreConsecutives, _ref;\n\n  _ref = require('./scorer'), isMatch = _ref.isMatch, isWordStart = _ref.isWordStart, scoreConsecutives = _ref.scoreConsecutives, scoreCharacter = _ref.scoreCharacter, scoreAcronyms = _ref.scoreAcronyms;\n\n  exports.match = match = function(string, query, options) {\n    var allowErrors, baseMatches, matches, pathSeparator, preparedQuery, string_lw;\n    allowErrors = options.allowErrors, preparedQuery = options.preparedQuery, pathSeparator = options.pathSeparator;\n    if (!(allowErrors || isMatch(string, preparedQuery.core_lw, preparedQuery.core_up))) {\n      return [];\n    }\n    string_lw = string.toLowerCase();\n    matches = computeMatch(string, string_lw, preparedQuery);\n    if (matches.length === 0) {\n      return matches;\n    }\n    if (string.indexOf(pathSeparator) > -1) {\n      baseMatches = basenameMatch(string, string_lw, preparedQuery, pathSeparator);\n      matches = mergeMatches(matches, baseMatches);\n    }\n    return matches;\n  };\n\n  exports.wrap = function(string, query, options) {\n    var matchIndex, matchPos, matchPositions, output, strPos, tagClass, tagClose, tagOpen, _ref1;\n    if ((options.wrap != null)) {\n      _ref1 = options.wrap, tagClass = _ref1.tagClass, tagOpen = _ref1.tagOpen, tagClose = _ref1.tagClose;\n    }\n    if (tagClass == null) {\n      tagClass = 'highlight';\n    }\n    if (tagOpen == null) {\n      tagOpen = '<strong class=\"' + tagClass + '\">';\n    }\n    if (tagClose == null) {\n      tagClose = '</strong>';\n    }\n    if (string === query) {\n      return tagOpen + string + tagClose;\n    }\n    matchPositions = match(string, query, options);\n    if (matchPositions.length === 0) {\n      return string;\n    }\n    output = '';\n    matchIndex = -1;\n    strPos = 0;\n    while (++matchIndex < matchPositions.length) {\n      matchPos = matchPositions[matchIndex];\n      if (matchPos > strPos) {\n        output += string.substring(strPos, matchPos);\n        strPos = matchPos;\n      }\n      while (++matchIndex < matchPositions.length) {\n        if (matchPositions[matchIndex] === matchPos + 1) {\n          matchPos++;\n        } else {\n          matchIndex--;\n          break;\n        }\n      }\n      matchPos++;\n      if (matchPos > strPos) {\n        output += tagOpen;\n        output += string.substring(strPos, matchPos);\n        output += tagClose;\n        strPos = matchPos;\n      }\n    }\n    if (strPos <= string.length - 1) {\n      output += string.substring(strPos);\n    }\n    return output;\n  };\n\n  basenameMatch = function(subject, subject_lw, preparedQuery, pathSeparator) {\n    var basePos, depth, end;\n    end = subject.length - 1;\n    while (subject[end] === pathSeparator) {\n      end--;\n    }\n    basePos = subject.lastIndexOf(pathSeparator, end);\n    if (basePos === -1) {\n      return [];\n    }\n    depth = preparedQuery.depth;\n    while (depth-- > 0) {\n      basePos = subject.lastIndexOf(pathSeparator, basePos - 1);\n      if (basePos === -1) {\n        return [];\n      }\n    }\n    basePos++;\n    end++;\n    return computeMatch(subject.slice(basePos, end), subject_lw.slice(basePos, end), preparedQuery, basePos);\n  };\n\n  mergeMatches = function(a, b) {\n    var ai, bj, i, j, m, n, out;\n    m = a.length;\n    n = b.length;\n    if (n === 0) {\n      return a.slice();\n    }\n    if (m === 0) {\n      return b.slice();\n    }\n    i = -1;\n    j = 0;\n    bj = b[j];\n    out = [];\n    while (++i < m) {\n      ai = a[i];\n      while (bj <= ai && ++j < n) {\n        if (bj < ai) {\n          out.push(bj);\n        }\n        bj = b[j];\n      }\n      out.push(ai);\n    }\n    while (j < n) {\n      out.push(b[j++]);\n    }\n    return out;\n  };\n\n  computeMatch = function(subject, subject_lw, preparedQuery, offset) {\n    var DIAGONAL, LEFT, STOP, UP, acro_score, align, backtrack, csc_diag, csc_row, csc_score, i, j, m, matches, move, n, pos, query, query_lw, score, score_diag, score_row, score_up, si_lw, start, trace;\n    if (offset == null) {\n      offset = 0;\n    }\n    query = preparedQuery.query;\n    query_lw = preparedQuery.query_lw;\n    m = subject.length;\n    n = query.length;\n    acro_score = scoreAcronyms(subject, subject_lw, query, query_lw).score;\n    score_row = new Array(n);\n    csc_row = new Array(n);\n    STOP = 0;\n    UP = 1;\n    LEFT = 2;\n    DIAGONAL = 3;\n    trace = new Array(m * n);\n    pos = -1;\n    j = -1;\n    while (++j < n) {\n      score_row[j] = 0;\n      csc_row[j] = 0;\n    }\n    i = -1;\n    while (++i < m) {\n      score = 0;\n      score_up = 0;\n      csc_diag = 0;\n      si_lw = subject_lw[i];\n      j = -1;\n      while (++j < n) {\n        csc_score = 0;\n        align = 0;\n        score_diag = score_up;\n        if (query_lw[j] === si_lw) {\n          start = isWordStart(i, subject, subject_lw);\n          csc_score = csc_diag > 0 ? csc_diag : scoreConsecutives(subject, subject_lw, query, query_lw, i, j, start);\n          align = score_diag + scoreCharacter(i, j, start, acro_score, csc_score);\n        }\n        score_up = score_row[j];\n        csc_diag = csc_row[j];\n        if (score > score_up) {\n          move = LEFT;\n        } else {\n          score = score_up;\n          move = UP;\n        }\n        if (align > score) {\n          score = align;\n          move = DIAGONAL;\n        } else {\n          csc_score = 0;\n        }\n        score_row[j] = score;\n        csc_row[j] = csc_score;\n        trace[++pos] = score > 0 ? move : STOP;\n      }\n    }\n    i = m - 1;\n    j = n - 1;\n    pos = i * n + j;\n    backtrack = true;\n    matches = [];\n    while (backtrack && i >= 0 && j >= 0) {\n      switch (trace[pos]) {\n        case UP:\n          i--;\n          pos -= n;\n          break;\n        case LEFT:\n          j--;\n          pos--;\n          break;\n        case DIAGONAL:\n          matches.push(i + offset);\n          j--;\n          i--;\n          pos -= n + 1;\n          break;\n        default:\n          backtrack = false;\n      }\n    }\n    matches.reverse();\n    return matches;\n  };\n\n}).call(this);\n"],"sourceRoot":""}