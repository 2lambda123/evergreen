(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{OuUE:function(e,n,t){"use strict";t.r(n),t.d(n,"_frontmatter",(function(){return m})),t.d(n,"default",(function(){return h}));var a=t("zLVn"),o=t("mXGw"),i=t.n(o),r=t("7ljp"),c=t("qhky"),l=t("hPyG"),s=t("zngv"),p=t("7oih"),b=t("nD8F"),u=t("fKWt"),m={},d={_frontmatter:m},g=function(e){var n=e.children;return i.a.createElement(p.a,null,i.a.createElement(c.b,null,i.a.createElement("title",null,"Migration Guide · Evergreen")),i.a.createElement("div",{className:"MainLayout"},i.a.createElement(s.a,null),i.a.createElement("main",{className:"MainLayout-main"},i.a.createElement("div",{className:"MainLayout-content"},i.a.createElement("section",{className:"MainLayout-contentRight"},i.a.createElement("div",{className:"Container-nextToSidebar",style:{marginBottom:160}},i.a.createElement("div",{className:"Content"},i.a.createElement(l.a,null,n))))),i.a.createElement(u.a,null))),i.a.createElement(b.a,null))};function h(e){var n=e.components,t=Object(a.a)(e,["components"]);return Object(r.b)(g,Object.assign({},d,t,{components:n,mdxType:"MDXLayout"}),Object(r.b)("h2",null,"Evergreen v5 Migration Guide"),Object(r.b)("p",null,"Evergreen v5 is a general health check for the framework. We took a look at what makes Evergreen tick\nand compared it to new standards. We made several updates to try and push the DevX of using the framework\nto be a lot more natural and robust. Below you can see some of the changes we made that may require some\nwork on your side to to upgrade to v5."),Object(r.b)("h3",null,"Breaking Changes"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object.assign({parentName:"li"},{href:"#refs"}),"innerRef is gone. Use ref")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object.assign({parentName:"li"},{href:"#popovers"}),"Popover triggers")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object.assign({parentName:"li"},{href:"#icons"}),"Importing and using Icons")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object.assign({parentName:"li"},{href:"#downshift"}),"Downshift v5")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object.assign({parentName:"li"},{href:"#switch"}),"Switch no longer manages state")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object.assign({parentName:"li"},{href:"#radiogroup"}),"RadioGroup onChange arguments"))),Object(r.b)("h3",null,"innerRef no longer supported {#refs}"),Object(r.b)("p",null,"Previous versions of ",Object(r.b)("inlineCode",{parentName:"p"},"ui-box")," and Evergreen relied on passing around ",Object(r.b)("inlineCode",{parentName:"p"},"innerRef")," props to forward refs to the underlying components.\nWe've centralized on the standard way of using refs in React: passing a ",Object(r.b)("inlineCode",{parentName:"p"},"ref")," directly on the component. Almost all Evergreen components\nsupport forwarding refs."),Object(r.b)("p",null,"Note: If you find a component that you think should be forwarding refs and isn't, please open an issue on GitHub!"),Object(r.b)("p",null,"Here's an example of how to update your code:"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-diff",metastring:"static",static:!0})," const MyComponent = () => {\n   const inputRef = React.useRef()\n-  return <TextInput innerRef={inputRef} />\n+  return <TextInput ref={inputRef} />\n }\n")),Object(r.b)("h3",null,"Popover triggers {#popovers}"),Object(r.b)("p",null,"With the removal of ",Object(r.b)("inlineCode",{parentName:"p"},"innerRef")," in Evergreen, there are some potential changes required with implementations of ",Object(r.b)("inlineCode",{parentName:"p"},"Popover"),".\nThe direct ",Object(r.b)("inlineCode",{parentName:"p"},"child")," of a ",Object(r.b)("inlineCode",{parentName:"p"},"Popover")," ",Object(r.b)("strong",{parentName:"p"},"must be")," a component that can forward refs to a DOM node. If you are using class components,\nyou'll need to update your code. We've found the easiest path is to use an Evergreen component – which already handle ref forwarding.\nYou can see an example below:"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-diff",metastring:"static",static:!0}),'const MyComponent = () => {\n  return (\n    <Popover content={(<Heading size={400} padding={16}>Example Popover</Heading>)}\n+     <Pane display="inline-flex">\n        <MyClassComponent />\n+     </Pane>\n    </Popover>\n  )\n}\n')),Object(r.b)("p",null,"We recommend using ",Object(r.b)("inlineCode",{parentName:"p"},"Button")," or ",Object(r.b)("inlineCode",{parentName:"p"},"IconButton")," as the trigger, because it provides better accessibility:"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-diff",metastring:"static",static:!0}),"const MyComponent = () => {\n  return (\n    <Popover content={(<Heading size={400} padding={16}>Example Popover</Heading>)}\n-     <MyClassComponent />\n+     <Button>Click me!</Button>\n    </Popover>\n  )\n}\n")),Object(r.b)("h3",null,"Importing and using Icons {#icons}"),Object(r.b)("p",null,"Previously, the way we shipped icons in ",Object(r.b)("inlineCode",{parentName:"p"},"evergreen-ui@^4")," would significantly bloat bundle sizes. Even if you only\nused 1 icon from Evergreen, you would ship all 400+ icons to your end-users."),Object(r.b)("p",null,"In ",Object(r.b)("inlineCode",{parentName:"p"},"evergreen-ui@^4.26.0")," we introduced a new way to import icons that would lead to ",Object(r.b)("em",{parentName:"p"},"some amount")," of tree-shaking."),Object(r.b)("p",null,"Finally, in ",Object(r.b)("inlineCode",{parentName:"p"},"evergreen-ui@^5.0.0")," we have full tree-shaking support. This does impact the way you import icons (",Object(r.b)("inlineCode",{parentName:"p"},"import { Icon } from 'evergreen-ui'"),") and pass\nicons as props to other components like ",Object(r.b)("inlineCode",{parentName:"p"},"Button"),", ",Object(r.b)("inlineCode",{parentName:"p"},"IconButton"),", ",Object(r.b)("inlineCode",{parentName:"p"},"Menu.Item"),", ",Object(r.b)("inlineCode",{parentName:"p"},"OrderedList")," (and ",Object(r.b)("inlineCode",{parentName:"p"},"Ol"),"), ",Object(r.b)("inlineCode",{parentName:"p"},"UnorderedList")," (and ",Object(r.b)("inlineCode",{parentName:"p"},"Ul"),")."),Object(r.b)("p",null,"We updated all the components that internally were using the ",Object(r.b)("inlineCode",{parentName:"p"},"Icon")," component and updated the prop to no longer expect a string but a React node.\nWe also removed the ",Object(r.b)("inlineCode",{parentName:"p"},"Icon")," component from Evergreen itself. This means that all places you were using this component, you will need to\nupdate to use the new exported icons."),Object(r.b)("p",null,"There is also a codemod that can help you with this migration. It can be installed and used from the ",Object(r.b)("inlineCode",{parentName:"p"},"codemods")," directory. Notably it only\nupdates ",Object(r.b)("inlineCode",{parentName:"p"},"import { Icon } from 'evergreen-ui'"),"."),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-sh",metastring:"static",static:!0}),"npx jscodeshift -t node_modules/evergreen-ui/codemods/4.28.1.0-4.29.0/replace-icon-imports.js --parser=tsx --extensions=js,ts,tsx <your file target> --dry --print\n")),Object(r.b)("h4",null,"Migration path"),Object(r.b)("p",null,"Importing an icon:"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-diff",metastring:"static",static:!0}),"- import { Icon } from 'evergreen-ui'\n+ import { CogIcon } from 'evergreen-ui'\n \n- <Icon icon=\"cog\" />\n+ <CogIcon />\n")),Object(r.b)("p",null,"Passing an icon as a prop:"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-diff",metastring:"static",static:!0}),"- import { Button } from 'evergreen-ui'\n+ import { Button, CogIcon } from 'evergreen-ui'\n \n- <Button iconBefore=\"cog\">\n+ <Button iconBefore={CogIcon}>\n    Settings\n  </Button>\n")),Object(r.b)("h3",null,"Downshift v5 {#downshift}"),Object(r.b)("p",null,"We upgraded the version of Downshift we use internally in Evergreen from version ",Object(r.b)("inlineCode",{parentName:"p"},"3.3.1")," to ",Object(r.b)("inlineCode",{parentName:"p"},"5.2.0"),". As part of this some\ncomponent props have been deprecated and are no longer available in the components that use Downshift.\nSee the ",Object(r.b)("a",Object.assign({parentName:"p"},{href:"https://github.com/segmentio/evergreen/pull/792"}),"diff in #792"),"."),Object(r.b)("h4",null,"Components affected"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"AutoComplete")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"Combobox"))),Object(r.b)("h4",null,"Props removed"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"defaultSelectedItem")," - use ",Object(r.b)("inlineCode",{parentName:"li"},"initialSelectedItem")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"defaultInputValue")," - use ",Object(r.b)("inlineCode",{parentName:"li"},"initialInputValue")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"getButtonProps")," - use ",Object(r.b)("inlineCode",{parentName:"li"},"getToggleButtonProps"))),Object(r.b)("h3",null,"Switch is uncontrolled {#switch}"),Object(r.b)("p",null,"To unify usage of form components across Evergreen, we updated ",Object(r.b)("inlineCode",{parentName:"p"},"Switch")," to more closely match other components, such as ",Object(r.b)("inlineCode",{parentName:"p"},"Checkbox"),".\nWhen using the component it is now required that you pass the component an ",Object(r.b)("inlineCode",{parentName:"p"},"onChange")," callback method when wanting to manage state."),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-diff",metastring:"static",static:!0}),"const [switchIsActive, setSwitchActive] = useState(false)\n \n+ const onChange = (event) => {\n+   setSwitchActive(event.target.checked)\n+ }\n \n- <Switch checked={switchIsActive} />\n+ <Switch checked={switchIsActive} onChange={onChange} />\n")),Object(r.b)("h3",null,"Radio and RadioGroup onChange arguments {#radiogroup}"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"RadioGroup"),"'s ",Object(r.b)("inlineCode",{parentName:"p"},"onChange")," handler now bubbles the ",Object(r.b)("em",{parentName:"p"},"event")," directly from children ",Object(r.b)("inlineCode",{parentName:"p"},"Radio")," inputs instead of bubbling the ",Object(r.b)("em",{parentName:"p"},"value"),"."),Object(r.b)("p",null,"This change was made to help improve the internal consistency with ",Object(r.b)("inlineCode",{parentName:"p"},"onChange")," handlers and to more closely match ",Object(r.b)("inlineCode",{parentName:"p"},"onChange")," event signature expecations."),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-diff",metastring:"static",static:!0}),"const items = [{ label: 'one', value: '1' }, { label: 'two', value: '2' }]\nconst [selected, setSelected] = useState()\n\n<RadioGroup\n  items={items}\n-  onChange={selectedValue => setSelected(selectedValue)}\n+  onChange={event => setSelected(event.target.value)}\n/>\n")),Object(r.b)("p",null,"Similarly, we removed the second argument from ",Object(r.b)("inlineCode",{parentName:"p"},"Radio"),"'s ",Object(r.b)("inlineCode",{parentName:"p"},"onChange")," handler:"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-diff",metastring:"static",static:!0}),"- <Radio onChange={(event, checked) => console.log(checked)} />\n- <Radio onChange={(event) => console.log(event.target.checked)} />\n")))}h.isMDXComponent=!0},fKWt:function(e,n,t){"use strict";t.d(n,"a",(function(){return s}));var a=t("dI71"),o=t("mXGw"),i=t.n(o),r=t("zLVn"),c=t("Wbzz"),l=function(e){function n(){return e.apply(this,arguments)||this}return Object(a.a)(n,e),n.prototype.render=function(){var e=this.props,n=(e.children,e.groups),t=Object(r.a)(e,["children","groups"]);return i.a.createElement("aside",Object.assign({className:"MainLayout-sidebar Sidebar"},t),i.a.createElement("div",{className:"Sidebar-inner"},n.map((function(e){return i.a.createElement("div",{key:e.title||e.links[0].label,className:"NavGroup"},e.title&&i.a.createElement("h3",{className:"NavGroup-title"},e.title),i.a.createElement("nav",{className:"NavGroup-nav"},e.links.map((function(e){var n=e.label,t=e.to,a=e.exact;return i.a.createElement(c.a,{key:t,activeClassName:"is-active",to:t,exact:a},n)}))))}))))},n}(o.PureComponent);l.defaultProps={groups:[]};var s=function(e){function n(){return e.apply(this,arguments)||this}return Object(a.a)(n,e),n.prototype.render=function(){return i.a.createElement(l,this.props)},n}(o.PureComponent);s.defaultProps={groups:[{links:[{to:"/get-started/introduction",label:"Introduction"},{to:"/get-started/theming",label:"Theming"},{to:"/get-started/v5-migration-guide",label:"Migrating to v5"}]}]}}}]);
//# sourceMappingURL=component---src-pages-get-started-v-5-migration-guide-mdx-ac66c1104a96e21bf18c.js.map