{"version":3,"sources":["webpack:///./node_modules/core-js/modules/es6.function.name.js","webpack:///./node_modules/core-js/modules/es6.string.trim.js","webpack:///./node_modules/fuzzaldrin-plus/lib/fuzzaldrin.js","webpack:///./node_modules/core-js/modules/_string-trim.js","webpack:///./node_modules/fuzzaldrin-plus/lib/scorer.js","webpack:///./node_modules/core-js/modules/_string-ws.js","webpack:///./node_modules/fuzzaldrin-plus/lib/pathScorer.js","webpack:///./node_modules/process/browser.js","webpack:///./node_modules/fuzzaldrin-plus/lib/query.js","webpack:///./node_modules/fuzzaldrin-plus/lib/filter.js","webpack:///./node_modules/fuzzaldrin-plus/lib/matcher.js"],"names":["dP","__webpack_require__","f","FProto","Function","prototype","nameRE","configurable","get","this","match","e","$trim","process","Query","defaultPathSeparator","filter","matcher","parseOptions","pathScorer","preparedQueryCache","scorer","platform","module","exports","candidates","query","options","length","score","string","usePathScoring","_results","_i","_ref","push","apply","wrap","prepareQuery","preparedQuery","allowErrors","useExtensionBonus","pathSeparator","optCharRegEx","call","$export","defined","fails","spaces","space","ltrim","RegExp","rtrim","exporter","KEY","exec","ALIAS","exp","FORCE","fn","trim","P","F","TYPE","String","replace","AcronymResult","computeScore","emptyAcronymResult","isAcronymFullWord","isMatch","isSeparator","isWordEnd","isWordStart","scoreAcronyms","scoreCharacter","scoreConsecutives","scoreExact","scoreExactMatch","scorePattern","scorePosition","scoreSize","string_lw","core_lw","core_up","toLowerCase","Math","ceil","subject","query_lw","query_up","i","j","m","n","qj_lw","qj_up","si","charCodeAt","subject_lw","acro","acro_score","align","csc_diag","csc_row","csc_score","csc_should_rebuild","miss_budget","miss_left","pos","record_miss","score_diag","score_row","score_up","si_lw","start","sz","count","indexOf","Array","charCodes","max","curr_s","prev_s","len","next_s","c","sc","abs","quality","sameCase","end","bonus","posBonus","startOfWord","k","mi","nj","pos2","fullWord","sepCount","sumPos","nbAcronymInQuery","countDir","getExtensionScore","scorePath","fullPathScore","alpha","basePathScore","basePos","depth","extAdjust","fileLength","lastIndexOf","ext","slice","path","getExtension","str","substr","candidate","startPos","endPos","maxDepth","matched","cachedSetTimeout","cachedClearTimeout","defaultSetTimout","Error","defaultClearTimeout","runTimeout","fun","setTimeout","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","concat","drainQueue","timeout","run","marker","runClearTimeout","Item","array","noop","nextTick","args","arguments","title","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","name","binding","cwd","chdir","dir","umask","coreChars","getCharCodes","opt_char_re","truncatedUpperCase","_arg","_ref1","core","upper","_len","toUpperCase","pluckCandidates","sortCandidates","a","b","bKey","key","maxInners","maxResults","scoreProvider","scoredCandidates","spotLeft","sort","map","basenameMatch","computeMatch","mergeMatches","baseMatches","matches","matchIndex","matchPos","matchPositions","output","strPos","tagClass","tagClose","tagOpen","substring","ai","bj","out","offset","backtrack","move","trace","reverse"],"mappings":"6EAAA,IAAAA,EAAAC,EAAA,IAAAC,EACAC,EAAAC,SAAAC,UACAC,EAAA,wBACA,SAGAH,GAAAF,EAAA,KAAAD,EAAAG,EAHA,OAGA,CACAI,cAAA,EACAC,IAAA,WACA,IACA,UAAAC,MAAAC,MAAAJ,GAAA,GACK,MAAAK,GACL,+CCVAV,EAAA,IAAAA,CAAA,gBAAAW,GACA,kBACA,OAAAA,EAAAH,KAAA,4BCJA,SAAAI,IAAA,WACA,IAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAEAL,EAAAf,EAAA,KAEAgB,EAAAhB,EAAA,KAEAoB,EAAApB,EAAA,KAEAkB,EAAAlB,EAAA,KAEAa,EAAAb,EAAA,KAEAmB,EAAA,KAEAL,EAAA,iBAAAF,IAAAS,cAAA,YAEAC,EAAAC,QAAA,CACAR,OAAA,SAAAS,EAAAC,EAAAC,GAIA,OAHA,MAAAA,IACAA,EAAA,KAEA,MAAAD,IAAAE,YAAA,WAAAH,IAAAG,YAAA,IAGAD,EAAAT,EAAAS,EAAAD,GACAV,EAAAS,EAAAC,EAAAC,IAHA,IAKAE,MAAA,SAAAC,EAAAJ,EAAAC,GAIA,OAHA,MAAAA,IACAA,EAAA,KAEA,MAAAG,IAAAF,YAAA,WAAAF,IAAAE,YAAA,IAGAD,EAAAT,EAAAS,EAAAD,IACAK,eACAZ,EAAAU,MAAAC,EAAAJ,EAAAC,GAEAN,EAAAQ,MAAAC,EAAAJ,EAAAC,GANA,GASAjB,MAAA,SAAAoB,EAAAJ,EAAAC,GACA,IAAAK,EAIA,OAHA,MAAAL,IACAA,EAAA,IAEAG,GAGAJ,EAGAI,IAAAJ,EACA,WACAM,EAAA,GACA,QAAAC,EAAA,EAAAC,EAAAJ,EAAAF,OAAgD,GAAAM,EAAAD,EAAAC,EAAAD,EAAAC,EAAmC,GAAAA,EAAAD,QAA0BD,EAAAG,KAAAF,GAC7G,OAAAD,GACSI,MAAA3B,OAETkB,EAAAT,EAAAS,EAAAD,GACAT,EAAAP,MAAAoB,EAAAJ,EAAAC,IAbA,IAeAU,KAAA,SAAAP,EAAAJ,EAAAC,GAIA,OAHA,MAAAA,IACAA,EAAA,IAEAG,GAGAJ,GAGAC,EAAAT,EAAAS,EAAAD,GACAT,EAAAoB,KAAAP,EAAAJ,EAAAC,IANA,IAQAW,aAAA,SAAAZ,EAAAC,GAKA,OAJA,MAAAA,IACAA,EAAA,KAEAA,EAAAT,EAAAS,EAAAD,IACAa,gBAIArB,EAAA,SAAAS,EAAAD,GAsBA,OArBA,MAAAC,EAAAa,cACAb,EAAAa,aAAA,GAEA,MAAAb,EAAAI,iBACAJ,EAAAI,gBAAA,GAEA,MAAAJ,EAAAc,oBACAd,EAAAc,mBAAA,GAEA,MAAAd,EAAAe,gBACAf,EAAAe,cAAA3B,GAEA,MAAAY,EAAAgB,eACAhB,EAAAgB,aAAA,MAEA,MAAAhB,EAAAU,OACAV,EAAAU,KAAA,MAEA,MAAAV,EAAAY,gBACAZ,EAAAY,cAAAnB,KAAAM,UAAAN,IAAA,IAAAN,EAAAY,EAAAC,IAEAA,KAGCiB,KAAAnC,+CC9GD,IAAAoC,EAAA5C,EAAA,IACA6C,EAAA7C,EAAA,IACA8C,EAAA9C,EAAA,IACA+C,EAAA/C,EAAA,KACAgD,EAAA,IAAAD,EAAA,IAEAE,EAAAC,OAAA,IAAAF,IAAA,KACAG,EAAAD,OAAAF,IAAA,MAEAI,EAAA,SAAAC,EAAAC,EAAAC,GACA,IAAAC,EAAA,GACAC,EAAAX,EAAA,WACA,QAAAC,EAAAM,MAPA,WAOAA,OAEAK,EAAAF,EAAAH,GAAAI,EAAAH,EAAAK,GAAAZ,EAAAM,GACAE,IAAAC,EAAAD,GAAAG,GACAd,IAAAgB,EAAAhB,EAAAiB,EAAAJ,EAAA,SAAAD,IAMAG,EAAAP,EAAAO,KAAA,SAAA9B,EAAAiC,GAIA,OAHAjC,EAAAkC,OAAAlB,EAAAhB,IACA,EAAAiC,IAAAjC,IAAAmC,QAAAf,EAAA,KACA,EAAAa,IAAAjC,IAAAmC,QAAAb,EAAA,KACAtB,GAGAP,EAAAC,QAAA6B,sBC7BA,WACA,IAAAa,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAUAzD,EAAAK,MAAA,SAAAC,EAAAJ,EAAAC,GACA,IAAAY,EAAAV,EAAAqD,EAEA,OADA3C,EAAAZ,EAAAY,cAAAZ,EAAAa,aACA8B,EAAAxC,EAAAS,EAAA4C,QAAA5C,EAAA6C,UAGAF,EAAApD,EAAAuD,cACAxD,EAAAsC,EAAArC,EAAAoD,EAAA3C,GACA+C,KAAAC,KAAA1D,IAJA,GAOAL,EAAA8C,UAAA,SAAAkB,EAAAC,EAAAC,GACA,IAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAGA,GAFAJ,EAAAL,EAAA5D,OACAkE,EAAAL,EAAA7D,QACAiE,GAAAC,EAAAD,EACA,SAIA,IAFAF,GAAA,EACAC,GAAA,IACAA,EAAAE,GAAA,CAGA,IAFAC,EAAAN,EAAAS,WAAAN,GACAI,EAAAN,EAAAQ,WAAAN,KACAD,EAAAE,IACAI,EAAAT,EAAAU,WAAAP,MACAI,GAAAE,IAAAD,IAIA,GAAAL,IAAAE,EACA,SAGA,UAGArE,EAAA2C,eAAA,SAAAqB,EAAAW,EAAA5D,GACA,IAAA6D,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAf,EAAAC,EAAAC,EAAAc,EAAAC,EAAAd,EAAAe,EAAAnF,EAAA+D,EAAAqB,EAAAjF,EAAAkF,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAOA,GANA1F,EAAAa,EAAAb,MACA+D,EAAAlD,EAAAkD,SACAI,EAAAL,EAAA5D,OACAkE,EAAApE,EAAAE,OAEAyE,GADAD,EAAA1B,EAAAc,EAAAW,EAAAzE,EAAA+D,IACA5D,MACAuE,EAAAiB,QAAAvB,EACA,OAAAjB,EAAAiB,EAAAD,EAAAQ,EAAAD,EAAAS,KAGA,IADAA,EAAAV,EAAAmB,QAAA7B,KACA,EACA,OAAAX,EAAAU,EAAAW,EAAAzE,EAAA+D,EAAAoB,EAAAf,EAAAD,GASA,IAPAmB,EAAA,IAAAO,MAAAzB,GACAU,EAAA,IAAAe,MAAAzB,GACAsB,EAAAnC,EAAAa,EAAAD,GAEAe,EADAD,EAAArB,KAAAC,KAxDA,IAwDAO,GAAA,EAEAY,GAAA,EACAd,GAAA,IACAA,EAAAE,GACAkB,EAAApB,GAAA,EACAY,EAAAZ,GAAA,EAGA,IADAD,GAAA,IACAA,EAAAE,GAEA,KADAqB,EAAAf,EAAAR,IACAO,WAAA,KAAA3D,EAAAiF,WACA,GAAAd,EAAA,CAEA,IADAd,GAAA,IACAA,EAAAE,GACAU,EAAAZ,GAAA,EAEAc,GAAA,QAUA,IANA7E,EAAA,EACAkF,EAAA,EACAR,EAAA,EACAO,GAAA,EACAJ,GAAA,EACAd,GAAA,IACAA,EAAAE,GAAA,CAMA,IALAmB,EAAAD,EAAApB,IACA/D,IACAA,EAAAoF,GAEAR,EAAA,EACAhB,EAAAG,KAAAsB,EAIA,GAHAC,EAAA1C,EAAAkB,EAAAH,EAAAW,GACAM,EAAAF,EAAA,EAAAA,EAAA3B,EAAAY,EAAAW,EAAAzE,EAAA+D,EAAAE,EAAAC,EAAAuB,IACAb,EAAAS,EAAApC,EAAAgB,EAAAC,EAAAuB,EAAAd,EAAAI,IACA5E,EACAA,EAAAyE,EACAM,EAAAD,MACW,CACX,GAAAG,KAAAF,GAAA,EACA,OAAAtB,KAAAmC,IAAA5F,EAAAmF,EAAAlB,EAAA,IAAAsB,EAEAN,GAAA,EAGAC,EAAAE,EACAV,EAAAC,EAAAZ,GACAY,EAAAZ,GAAAa,EACAO,EAAApB,GAAA/D,EAIA,OADAA,EAAAmF,EAAAlB,EAAA,IACAsB,GAGA5F,EAAAiD,cAAA,SAAAoC,EAAArB,EAAAW,GACA,IAAAuB,EAAAC,EACA,WAAAd,IAGAa,EAAAlC,EAAAqB,GACAc,EAAAnC,EAAAqB,EAAA,GACAtC,EAAAoD,IAAAD,IAAAvB,EAAAU,IAAAc,IAAAxB,EAAAU,EAAA,KAGArF,EAAAgD,YAAA,SAAAqC,EAAArB,EAAAW,EAAAyB,GACA,IAAAF,EAAAG,EACA,OAAAhB,IAAAe,EAAA,IAGAF,EAAAlC,EAAAqB,GACAgB,EAAArC,EAAAqB,EAAA,GACAtC,EAAAsD,IAAAH,IAAAvB,EAAAU,IAAAgB,IAAA1B,EAAAU,EAAA,KAGAtC,EAAA,SAAAuD,GACA,YAAAA,GAAA,MAAAA,GAAA,MAAAA,GAAA,MAAAA,GAAA,MAAAA,GAAA,OAAAA,GAGA9C,EAAA,SAAA6B,GACA,IAAAkB,EACA,OAAAlB,EA/IA,GAiJA,KADAkB,EAhJA,GAgJAlB,GACAkB,EAEAzC,KAAAmC,IAAA,IAAAZ,EAAA,IAIArF,EAAAyD,YAAA,SAAAa,EAAAD,GACA,OAtJA,SAsJAP,KAAA0C,IAAAnC,EAAAC,KAGAjB,EAAA,SAAAiB,EAAAD,EAAAoC,EAAApB,GACA,SAAAf,GA9JA,IA8JAmC,EAAAjD,EAAA6B,IAAA5B,EAAAa,EAAAD,IAGArE,EAAAuD,eAAA,SAAAsC,EAAAO,EAAAM,EAAAf,EAAAgB,GACA,IAAAC,EAAAhB,EAwBA,OAvBAA,EAAAC,EACAe,EAAA,EACAF,IAAAb,IACAe,GAAA,GAEAjB,IACAiB,GAAA,GAEAD,IACAC,GAAA,GAEAf,IAAAO,IACAT,IAEAC,GADAc,IAAAN,EACA,EAEA,GAGAO,IACAC,GAAA,IAGAF,EAAAd,KAAAgB,IAGA5G,EAAAmD,iBAAA,SAAAgB,EAAAC,EAAAuB,EAAAd,EAAAI,GACA,IAAA4B,EAEA,OADAA,EAAArD,EAAAW,GACAwB,EACAkB,EAjMA,MAiMAhC,EAAAI,EAAAJ,EAAAI,GAAA,IAEA4B,EAnMA,IAmMA5B,GAGAjF,EAAAoD,oBAAA,SAAAY,EAAAW,EAAAzE,EAAA+D,EAAAE,EAAAC,EAAA0C,GACA,IAAAC,EAAA1C,EAAA2C,EAAA1C,EAAA2C,EAAAP,EAAAd,EAWA,IANAmB,GAFAC,GAFA3C,EAAAL,EAAA5D,QAEA+D,IACA8C,GAFA3C,EAAApE,EAAAE,QAEAgE,GACA4C,EAAAC,EACAP,EAAA,EACAd,EAAA,EACA1F,EAAAkE,KAAAJ,EAAAG,IACAuC,MAEAd,EAAAmB,GAAA9C,IAAAG,KAAAO,IAAAR,IACAjE,EAAAkE,KAAAJ,EAAAG,IACAuC,IAMA,OAHAd,EAAAmB,GACA5C,IAEA,IAAAyB,EACA,IAAAc,EAEAnD,EAAAqC,EAAAtB,EAAAoC,EAAAI,EAAA9D,EAAAmB,EAAAH,EAAAW,EAAAN,KAGArE,EAAAsD,kBAAA,SAAAU,EAAAW,EAAAzE,EAAA+D,EAAAoB,EAAAf,EAAAD,GACA,IAAAsC,EAAAxC,EAAA+C,EAAAR,EAAAf,EAaA,KAZAA,EAAA1C,EAAAoC,EAAArB,EAAAW,MAEAuC,EAAAvC,EAAAmB,QAAA7B,EAAAoB,EAAA,KACA,IACAM,EAAA1C,EAAAiE,EAAAlD,EAAAW,MAEAU,EAAA6B,GAIA/C,GAAA,EACAuC,EAAA,IACAvC,EAAAG,GACApE,EAAAmF,EAAAlB,KAAAH,EAAAG,IACAuC,IAIA,OADAC,EAAA3D,EAAAqC,EAAAf,EAAA,EAAAN,EAAAW,EAAAN,GACAhB,EAAAiB,EAAAD,EAAAd,EAAAe,IAAAoC,EAAAf,EAAAgB,GAAAtB,IAGA3C,EAAA,WAOA,OANA,SAAArC,EAAAgF,EAAAQ,GACA5G,KAAAoB,QACApB,KAAAoG,MACApG,KAAA4G,SAJA,GAWAjD,EAAA,IAAAF,EAAA,QAEA1C,EAAAkD,gBAAA,SAAAc,EAAAW,EAAAzE,EAAA+D,GACA,IAAA4B,EAAAsB,EAAAhD,EAAAC,EAAAC,EAAAC,EAAAC,EAAAmC,EAAArG,EAAA+G,EAAAC,EAGA,GAFAhD,EAAAL,EAAA5D,OACAkE,EAAApE,EAAAE,SACAiE,EAAA,GAAAC,EAAA,GACA,OAAA1B,EAQA,IANAiD,EAAA,EACAuB,EAAA,EACAC,EAAA,EACAX,EAAA,EACAvC,GAAA,EACAC,GAAA,IACAA,EAAAE,GAAA,CAEA,GADAC,EAAAN,EAAAG,GACArB,EAAAwB,GAAA,CAEA,IADAJ,EAAAQ,EAAAmB,QAAAvB,EAAAJ,EAAA,KACA,GACAiD,IACA,SAEA,MAGA,OAAAjD,EAAAE,GACA,GAAAE,IAAAI,EAAAR,IAAAlB,EAAAkB,EAAAH,EAAAW,GAAA,CACAzE,EAAAkE,KAAAJ,EAAAG,IACAuC,IAEAW,GAAAlD,EACA0B,IACA,MAGA,GAAA1B,IAAAE,EACA,MAGA,OAAAwB,EAAA,EACAjD,GAEAuE,EAAAtB,IAAAvB,GAAAzB,EAAAmB,EAAAW,EAAAzE,EAAA2F,GACAxF,EAAAkD,EAAAsC,EAAAvB,EAAAoC,GAAA,EAAAS,GACA,IAAAzE,EAAArC,EAAAgH,EAAAxB,IAAAuB,KAGAvE,EAAA,SAAAmB,EAAAW,EAAAzE,EAAAoH,GACA,IAAAzB,EAAA1B,EAAAE,EAIA,GADAwB,EAAA,GAFAxB,EAAAL,EAAA5D,QAGA,GAFAF,EAAAE,OAGA,SAGA,IADA+D,GAAA,IACAA,EAAAE,GACA,GAAApB,EAAAkB,EAAAH,EAAAW,MAAAkB,EAAAyB,EACA,SAGA,YAGClG,KAAAnC,yBCtUDc,EAAAC,QAAA,uECAA,WACA,IAAA2C,EAAA4E,EAAAC,EAAA1E,EAAA2E,EAAAhE,EAAA/C,EAEAA,EAAAjC,EAAA,KAAAqE,EAAApC,EAAAoC,QAAAH,EAAAjC,EAAAiC,aAAAc,EAAA/C,EAAA+C,UAMAzD,EAAAK,MAAA,SAAAC,EAAAJ,EAAAC,GACA,IAAAY,EAAAV,EAAAqD,EAEA,OADA3C,EAAAZ,EAAAY,cAAAZ,EAAAa,aACA8B,EAAAxC,EAAAS,EAAA4C,QAAA5C,EAAA6C,UAGAF,EAAApD,EAAAuD,cACAxD,EAAAsC,EAAArC,EAAAoD,EAAA3C,GACAV,EAAAoH,EAAAnH,EAAAoD,EAAArD,EAAAF,GACA2D,KAAAC,KAAA1D,IALA,GAQAoH,EAAA,SAAAzD,EAAAW,EAAA+C,EAAAvH,GACA,IAAAwH,EAAAC,EAAAC,EAAAC,EAAAnB,EAAAoB,EAAAC,EAAA9G,EAAAH,EAAAE,EACA,OAAAyG,EACA,SAIA,IAFA3G,EAAAZ,EAAAY,cAAAE,EAAAd,EAAAc,kBAAAC,EAAAf,EAAAe,cACAyF,EAAA3C,EAAA5D,OAAA,EACA4D,EAAA2C,KAAAzF,GACAyF,IASA,GANAqB,EAAArB,GADAkB,EAAA7D,EAAAiE,YAAA/G,EAAAyF,IAEAoB,EAAA,EACA9G,IAEAyG,GADAK,GAAAP,EAAA7C,EAAA5D,EAAAmH,IAAAL,EAAAlB,EAAA,KAGA,IAAAkB,EACA,OAAAH,EAGA,IADAI,EAAA/G,EAAA+G,MACAD,GAAA,GAAAC,KAAA,GACAD,EAAA7D,EAAAiE,YAAA/G,EAAA2G,EAAA,GAIA,OAFAD,GAAA,IAAAC,EAAAH,EAAAK,EAAApF,EAAAqB,EAAAmE,MAAAN,EAAA,EAAAlB,EAAA,GAAAhC,EAAAwD,MAAAN,EAAA,EAAAlB,EAAA,GAAA5F,IACA4G,EAAA,IAzCA,GAyCAJ,EAAAvD,EAAA2C,EAAA,EAAAzF,KACA0G,GAAA,EAAAD,GAAAD,EAAAjE,EAAA,EAxCA,IAwCAuE,IAGAhI,EAAAuH,WAAA,SAAAa,EAAAzB,EAAAzF,GACA,IAAA2E,EAAA1B,EACA,GAAAwC,EAAA,EACA,SAIA,IAFAd,EAAA,EACA1B,GAAA,IACAA,EAAAwC,GAAAyB,EAAAjE,KAAAjD,IAGA,OAAAiD,EAAAwC,GACA,GAAAyB,EAAAjE,KAAAjD,EAEA,IADA2E,MACA1B,EAAAwC,GAAAyB,EAAAjE,KAAAjD,IAKA,OAAA2E,GAGA7F,EAAAqI,aAAA,SAAAC,GACA,IAAAjD,EAEA,OADAA,EAAAiD,EAAAL,YAAA,MACA,EACA,GAEAK,EAAAC,OAAAlD,EAAA,IAIAmC,EAAA,SAAAgB,EAAAN,EAAAO,EAAAC,EAAAC,GACA,IAAAtE,EAAAuE,EAAAtE,EAAAe,EACA,IAAA6C,EAAA9H,OACA,SAGA,MADAiF,EAAAmD,EAAAP,YAAA,IAAAS,IACAD,GACA,SAUA,KAPApE,EAAAqE,EAAArD,IADAf,EAAA4D,EAAA9H,UAGAkE,EAAAD,EACAA,EAAA6D,EAAA9H,QAEAiF,IACAuD,GAAA,IACAA,EAAAtE,GACAkE,EAAAnD,EAAAuD,KAAAV,EAAAU,KAIA,WAAAA,GAAAD,EAAA,EACA,GAAAnB,EAAAgB,EAAAN,EAAAO,EAAApD,EAAA,EAAAsD,EAAA,GAEAC,EAAAvE,KAGCjD,KAAAnC,yBC5GD,IAOA4J,EACAC,EARAzJ,EAAAU,EAAAC,QAAA,GAUA,SAAA+I,IACA,UAAAC,MAAA,mCAEA,SAAAC,IACA,UAAAD,MAAA,qCAsBA,SAAAE,EAAAC,GACA,GAAAN,IAAAO,WAEA,OAAAA,WAAAD,EAAA,GAGA,IAAAN,IAAAE,IAAAF,IAAAO,WAEA,OADAP,EAAAO,WACAA,WAAAD,EAAA,GAEA,IAEA,OAAAN,EAAAM,EAAA,GACK,MAAAhK,GACL,IAEA,OAAA0J,EAAAzH,KAAA,KAAA+H,EAAA,GACS,MAAAhK,GAET,OAAA0J,EAAAzH,KAAAnC,KAAAkK,EAAA,MAvCA,WACA,IAEAN,EADA,mBAAAO,WACAA,WAEAL,EAEK,MAAA5J,GACL0J,EAAAE,EAEA,IAEAD,EADA,mBAAAO,aACAA,aAEAJ,EAEK,MAAA9J,GACL2J,EAAAG,GAjBA,GAwEA,IAEAK,EAFAC,EAAA,GACAC,GAAA,EAEAC,GAAA,EAEA,SAAAC,IACAF,GAAAF,IAGAE,GAAA,EACAF,EAAAlJ,OACAmJ,EAAAD,EAAAK,OAAAJ,GAEAE,GAAA,EAEAF,EAAAnJ,QACAwJ,KAIA,SAAAA,IACA,IAAAJ,EAAA,CAGA,IAAAK,EAAAX,EAAAQ,GACAF,GAAA,EAGA,IADA,IAAApD,EAAAmD,EAAAnJ,OACAgG,GAAA,CAGA,IAFAkD,EAAAC,EACAA,EAAA,KACAE,EAAArD,GACAkD,GACAA,EAAAG,GAAAK,MAGAL,GAAA,EACArD,EAAAmD,EAAAnJ,OAEAkJ,EAAA,KACAE,GAAA,EAnEA,SAAAO,GACA,GAAAjB,IAAAO,aAEA,OAAAA,aAAAU,GAGA,IAAAjB,IAAAG,IAAAH,IAAAO,aAEA,OADAP,EAAAO,aACAA,aAAAU,GAEA,IAEAjB,EAAAiB,GACK,MAAA5K,GACL,IAEA,OAAA2J,EAAA1H,KAAA,KAAA2I,GACS,MAAA5K,GAGT,OAAA2J,EAAA1H,KAAAnC,KAAA8K,KAgDAC,CAAAH,IAiBA,SAAAI,EAAAd,EAAAe,GACAjL,KAAAkK,MACAlK,KAAAiL,QAYA,SAAAC,KA5BA9K,EAAA+K,SAAA,SAAAjB,GACA,IAAAkB,EAAA,IAAAtE,MAAAuE,UAAAlK,OAAA,GACA,GAAAkK,UAAAlK,OAAA,EACA,QAAA+D,EAAA,EAAuBA,EAAAmG,UAAAlK,OAAsB+D,IAC7CkG,EAAAlG,EAAA,GAAAmG,UAAAnG,GAGAoF,EAAA5I,KAAA,IAAAsJ,EAAAd,EAAAkB,IACA,IAAAd,EAAAnJ,QAAAoJ,GACAN,EAAAU,IASAK,EAAApL,UAAAiL,IAAA,WACA7K,KAAAkK,IAAAvI,MAAA,KAAA3B,KAAAiL,QAEA7K,EAAAkL,MAAA,UACAlL,EAAAmL,SAAA,EACAnL,EAAAoL,IAAA,GACApL,EAAAqL,KAAA,GACArL,EAAAsL,QAAA,GACAtL,EAAAuL,SAAA,GAIAvL,EAAAwL,GAAAV,EACA9K,EAAAyL,YAAAX,EACA9K,EAAA0L,KAAAZ,EACA9K,EAAA2L,IAAAb,EACA9K,EAAA4L,eAAAd,EACA9K,EAAA6L,mBAAAf,EACA9K,EAAA8L,KAAAhB,EACA9K,EAAA+L,gBAAAjB,EACA9K,EAAAgM,oBAAAlB,EAEA9K,EAAAiM,UAAA,SAAAC,GAAqC,UAErClM,EAAAmM,QAAA,SAAAD,GACA,UAAAvC,MAAA,qCAGA3J,EAAAoM,IAAA,WAA2B,WAC3BpM,EAAAqM,MAAA,SAAAC,GACA,UAAA3C,MAAA,mCAEA3J,EAAAuM,MAAA,WAA4B,gCCvL5B,WACA,IAAAC,EAAAtE,EAAAuE,EAAAzD,EAAA0D,EAAAC,EAAAtL,EAEAA,EAAAjC,EAAA,KAAA8I,EAAA7G,EAAA6G,SAAAc,EAAA3H,EAAA2H,aAEAtI,EAAAC,QAAA,WAiBA,OAhBA,SAAAE,EAAA+L,GACA,IAAA9K,EAAAD,EAAAgL,EAEA,GADsC/K,GAAtC+K,EAAA,MAAAD,IAAA,IAAsC9K,aAAAD,EAAAgL,EAAAhL,eACtChB,MAAAE,OACA,YAEAnB,KAAAiB,QACAjB,KAAAgF,SAAA/D,EAAA2D,cACA5E,KAAAkN,KAAAN,EAAA3L,EAAAiB,GACAlC,KAAA0E,QAAA1E,KAAAkN,KAAAtI,cACA5E,KAAA2E,QAAAoI,EAAA/M,KAAAkN,MACAlN,KAAA6I,MAAAP,EAAArH,IAAAE,OAAAc,GACAjC,KAAAiJ,IAAAG,EAAApJ,KAAAgF,UACAhF,KAAA+G,UAAA8F,EAAA7M,KAAAgF,WAdA,GAqBA8H,EAAA,eAEAF,EAAA,SAAA3L,EAAAiB,GAIA,OAHA,MAAAA,IACAA,EAAA4K,GAEA7L,EAAAuC,QAAAtB,EAAA,KAGA6K,EAAA,SAAA1D,GACA,IAAA8D,EAAA3L,EAAA4L,EAEA,IADAD,EAAA,GACA3L,EAAA,EAAA4L,EAAA/D,EAAAlI,OAAmCK,EAAA4L,EAAW5L,IAE9C2L,GADA9D,EAAA7H,GACA6L,cAAA,GAEA,OAAAF,GAGAN,EAAA,SAAAxD,GACA,IAAAtC,EAAA7B,EAAAiC,EAIA,IAHAA,EAAAkC,EAAAlI,OACA+D,GAAA,EACA6B,EAAA,KACA7B,EAAAiC,GACAJ,EAAAsC,EAAA5D,WAAAP,KAAA,EAEA,OAAA6B,KAGC5E,KAAAnC,4BCxDD,WACA,IAAAU,EAAA4M,EAAA1M,EAAA2M,EAEA3M,EAAApB,EAAA,KAEAkB,EAAAlB,EAAA,KAEAA,EAAA,KAEA8N,EAAA,SAAAE,GACA,OAAAA,EAAAjE,WAGAgE,EAAA,SAAAC,EAAAC,GACA,OAAAA,EAAArM,MAAAoM,EAAApM,OAGAN,EAAAC,QAAA,SAAAC,EAAAC,EAAAC,GACA,IAAAwM,EAAAnE,EAAAoE,EAAAC,EAAAC,EAAAzM,EAAA0M,EAAAC,EAAAC,EAAA3M,EAAAC,EAAAE,EAAA4L,EAMA,IALAW,EAAA,GACAJ,EAAAzM,EAAAyM,IAAAE,EAAA3M,EAAA2M,WAAAD,EAAA1M,EAAA0M,UAAAtM,EAAAJ,EAAAI,eACA0M,EAAA,MAAAJ,KAAA,EAAAA,EAAA5M,EAAAG,OAAA,EACAuM,EAAA,MAAAC,EACAG,EAAAxM,EAAAZ,EAAAE,EACAY,EAAA,EAAA4L,EAAApM,EAAAG,OAA0CK,EAAA4L,IAC1C7D,EAAAvI,EAAAQ,MACAH,EAAAqM,EAAAnE,EAAAoE,GAAApE,KAIAnI,EAAA0M,EAAA1M,MAAAC,EAAAJ,EAAAC,IACA,KACA6M,EAAArM,KAAA,CACA6H,YACAnI,YAEA4M,IAZqDxM,KAsBrD,OALAuM,EAAAE,KAAAV,GACAvM,EAAA+M,EAAAG,IAAAZ,GACA,MAAAO,IACA7M,IAAAkI,MAAA,EAAA2E,IAEA7M,KAGCmB,KAAAnC,4BCjDD,WACA,IAAAmO,EAAAC,EAAAvK,EAAAG,EAAA/D,EAAAoO,EAAApK,EAAAC,EAAAC,EAAA1C,EAEAA,EAAAjC,EAAA,KAAAqE,EAAApC,EAAAoC,QAAAG,EAAAvC,EAAAuC,YAAAG,EAAA1C,EAAA0C,kBAAAD,EAAAzC,EAAAyC,eAAAD,EAAAxC,EAAAwC,cAEAlD,EAAAd,QAAA,SAAAoB,EAAAJ,EAAAC,GACA,IAAAa,EAAAuM,EAAAC,EAAAtM,EAAAH,EAAA2C,EAEA,OADA1C,EAAAb,EAAAa,YAAAD,EAAAZ,EAAAY,cAAAG,EAAAf,EAAAe,cACAF,GAAA8B,EAAAxC,EAAAS,EAAA4C,QAAA5C,EAAA6C,UAGAF,EAAApD,EAAAuD,cAEA,KADA2J,EAAAH,EAAA/M,EAAAoD,EAAA3C,IACAX,OACAoN,GAEAlN,EAAAwF,QAAA5E,IAAA,IACAqM,EAAAH,EAAA9M,EAAAoD,EAAA3C,EAAAG,GACAsM,EAAAF,EAAAE,EAAAD,IAEAC,IAXA,IAcAxN,EAAAa,KAAA,SAAAP,EAAAJ,EAAAC,GACA,IAAAsN,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAA9B,EAaA,GAZA,MAAA/L,EAAAU,OACAiN,GAAA5B,EAAA/L,EAAAU,MAAAiN,SAAAE,EAAA9B,EAAA8B,QAAAD,EAAA7B,EAAA6B,UAEA,MAAAD,IACAA,EAAA,aAEA,MAAAE,IACAA,EAAA,kBAAAF,EAAA,MAEA,MAAAC,IACAA,EAAA,aAEAzN,IAAAJ,EACA,OAAA8N,EAAA1N,EAAAyN,EAGA,QADAJ,EAAAzO,EAAAoB,EAAAJ,EAAAC,IACAC,OACA,OAAAE,EAKA,IAHAsN,EAAA,GACAH,GAAA,EACAI,EAAA,IACAJ,EAAAE,EAAAvN,QAAA,CAMA,KALAsN,EAAAC,EAAAF,IACAI,IACAD,GAAAtN,EAAA2N,UAAAJ,EAAAH,GACAG,EAAAH,KAEAD,EAAAE,EAAAvN,QAAA,CACA,GAAAuN,EAAAF,KAAAC,EAAA,EAES,CACTD,IACA,MAHAC,MAMAA,EACAG,IACAD,GAAAI,EACAJ,GAAAtN,EAAA2N,UAAAJ,EAAAH,GACAE,GAAAG,EACAF,EAAAH,GAMA,OAHAG,GAAAvN,EAAAF,OAAA,IACAwN,GAAAtN,EAAA2N,UAAAJ,IAEAD,GAGAR,EAAA,SAAApJ,EAAAW,EAAA5D,EAAAG,GACA,IAAA2G,EAAAC,EAAAnB,EAEA,IADAA,EAAA3C,EAAA5D,OAAA,EACA4D,EAAA2C,KAAAzF,GACAyF,IAGA,SADAkB,EAAA7D,EAAAiE,YAAA/G,EAAAyF,IAEA,SAGA,IADAmB,EAAA/G,EAAA+G,MACAA,KAAA,GAEA,SADAD,EAAA7D,EAAAiE,YAAA/G,EAAA2G,EAAA,IAEA,SAKA,OAFAA,IACAlB,IACA0G,EAAArJ,EAAAmE,MAAAN,EAAAlB,GAAAhC,EAAAwD,MAAAN,EAAAlB,GAAA5F,EAAA8G,IAGAyF,EAAA,SAAAb,EAAAC,GACA,IAAAwB,EAAAC,EAAAhK,EAAAC,EAAAC,EAAAC,EAAA8J,EAGA,GAFA/J,EAAAoI,EAAArM,OAEA,KADAkE,EAAAoI,EAAAtM,QAEA,OAAAqM,EAAAtE,QAEA,OAAA9D,EACA,OAAAqI,EAAAvE,QAMA,IAJAhE,GAAA,EAEAgK,EAAAzB,EADAtI,EAAA,GAEAgK,EAAA,KACAjK,EAAAE,GAAA,CAEA,IADA6J,EAAAzB,EAAAtI,GACAgK,GAAAD,KAAA9J,EAAAE,GACA6J,EAAAD,GACAE,EAAAzN,KAAAwN,GAEAA,EAAAzB,EAAAtI,GAEAgK,EAAAzN,KAAAuN,GAEA,KAAA9J,EAAAE,GACA8J,EAAAzN,KAAA+L,EAAAtI,MAEA,OAAAgK,GAGAf,EAAA,SAAArJ,EAAAW,EAAA5D,EAAAsN,GACA,IAAAxJ,EAAAC,EAAAwJ,EAAAvJ,EAAAC,EAAAC,EAAAd,EAAAC,EAAAC,EAAAmJ,EAAAe,EAAAjK,EAAAe,EAAAnF,EAAA+D,EAAA5D,EAAAkF,EAAAC,EAAAC,EAAAC,EAAAC,EAAA6I,EAkBA,IAjBA,MAAAH,IACAA,EAAA,GAEAnO,EAAAa,EAAAb,MACA+D,EAAAlD,EAAAkD,SACAI,EAAAL,EAAA5D,OACAkE,EAAApE,EAAAE,OACAyE,EAAA3B,EAAAc,EAAAW,EAAAzE,EAAA+D,GAAA5D,MACAmF,EAAA,IAAAO,MAAAzB,GACAU,EAAA,IAAAe,MAAAzB,GACA,EACA,EACA,EACA,EACAkK,EAAA,IAAAzI,MAAA1B,EAAAC,GACAe,GAAA,EACAjB,GAAA,IACAA,EAAAE,GACAkB,EAAApB,GAAA,EACAY,EAAAZ,GAAA,EAGA,IADAD,GAAA,IACAA,EAAAE,GAMA,IALAhE,EAAA,EACAoF,EAAA,EACAV,EAAA,EACAW,EAAAf,EAAAR,GACAC,GAAA,IACAA,EAAAE,GACAW,EAAA,EACAH,EAAA,EACAS,EAAAE,EACAxB,EAAAG,KAAAsB,IACAC,EAAA1C,EAAAkB,EAAAH,EAAAW,GACAM,EAAAF,EAAA,EAAAA,EAAA3B,EAAAY,EAAAW,EAAAzE,EAAA+D,EAAAE,EAAAC,EAAAuB,GACAb,EAAAS,EAAApC,EAAAgB,EAAAC,EAAAuB,EAAAd,EAAAI,IAEAQ,EAAAD,EAAApB,GACAW,EAAAC,EAAAZ,GACA/D,EAAAoF,EACA8I,EA5BA,GA8BAlO,EAAAoF,EACA8I,EAhCA,GAkCAzJ,EAAAzE,GACAA,EAAAyE,EACAyJ,EAlCA,GAoCAtJ,EAAA,EAEAO,EAAApB,GAAA/D,EACA2E,EAAAZ,GAAAa,EACAuJ,IAAAnJ,GAAAhF,EAAA,EAAAkO,EA3CA,EAmDA,IAHAlJ,GAFAlB,EAAAE,EAAA,GAEAC,GADAF,EAAAE,EAAA,GAEAgK,GAAA,EACAd,EAAA,GACAc,GAAAnK,GAAA,GAAAC,GAAA,GACA,OAAAoK,EAAAnJ,IACA,KApDA,EAqDAlB,IACAkB,GAAAf,EACA,MACA,KAvDA,EAwDAF,IACAiB,IACA,MACA,KA1DA,EA2DAmI,EAAA7M,KAAAwD,EAAAkK,GACAjK,IACAD,IACAkB,GAAAf,EAAA,EACA,MACA,QACAgK,GAAA,EAIA,OADAd,EAAAiB,UACAjB,KAGCpM,KAAAnC","file":"2-6b0f42a9fce126cb13db.js","sourcesContent":["var dP = require('./_object-dp').f;\nvar FProto = Function.prototype;\nvar nameRE = /^\\s*function ([^ (]*)/;\nvar NAME = 'name';\n\n// 19.2.4.2 name\nNAME in FProto || require('./_descriptors') && dP(FProto, NAME, {\n  configurable: true,\n  get: function () {\n    try {\n      return ('' + this).match(nameRE)[1];\n    } catch (e) {\n      return '';\n    }\n  }\n});\n","'use strict';\n// 21.1.3.25 String.prototype.trim()\nrequire('./_string-trim')('trim', function ($trim) {\n  return function trim() {\n    return $trim(this, 3);\n  };\n});\n","(function() {\n  var Query, defaultPathSeparator, filter, matcher, parseOptions, pathScorer, preparedQueryCache, scorer;\n\n  filter = require('./filter');\n\n  matcher = require('./matcher');\n\n  scorer = require('./scorer');\n\n  pathScorer = require('./pathScorer');\n\n  Query = require('./query');\n\n  preparedQueryCache = null;\n\n  defaultPathSeparator = (typeof process !== \"undefined\" && process !== null ? process.platform : void 0) === \"win32\" ? '\\\\' : '/';\n\n  module.exports = {\n    filter: function(candidates, query, options) {\n      if (options == null) {\n        options = {};\n      }\n      if (!((query != null ? query.length : void 0) && (candidates != null ? candidates.length : void 0))) {\n        return [];\n      }\n      options = parseOptions(options, query);\n      return filter(candidates, query, options);\n    },\n    score: function(string, query, options) {\n      if (options == null) {\n        options = {};\n      }\n      if (!((string != null ? string.length : void 0) && (query != null ? query.length : void 0))) {\n        return 0;\n      }\n      options = parseOptions(options, query);\n      if (options.usePathScoring) {\n        return pathScorer.score(string, query, options);\n      } else {\n        return scorer.score(string, query, options);\n      }\n    },\n    match: function(string, query, options) {\n      var _i, _ref, _results;\n      if (options == null) {\n        options = {};\n      }\n      if (!string) {\n        return [];\n      }\n      if (!query) {\n        return [];\n      }\n      if (string === query) {\n        return (function() {\n          _results = [];\n          for (var _i = 0, _ref = string.length; 0 <= _ref ? _i < _ref : _i > _ref; 0 <= _ref ? _i++ : _i--){ _results.push(_i); }\n          return _results;\n        }).apply(this);\n      }\n      options = parseOptions(options, query);\n      return matcher.match(string, query, options);\n    },\n    wrap: function(string, query, options) {\n      if (options == null) {\n        options = {};\n      }\n      if (!string) {\n        return [];\n      }\n      if (!query) {\n        return [];\n      }\n      options = parseOptions(options, query);\n      return matcher.wrap(string, query, options);\n    },\n    prepareQuery: function(query, options) {\n      if (options == null) {\n        options = {};\n      }\n      options = parseOptions(options, query);\n      return options.preparedQuery;\n    }\n  };\n\n  parseOptions = function(options, query) {\n    if (options.allowErrors == null) {\n      options.allowErrors = false;\n    }\n    if (options.usePathScoring == null) {\n      options.usePathScoring = true;\n    }\n    if (options.useExtensionBonus == null) {\n      options.useExtensionBonus = false;\n    }\n    if (options.pathSeparator == null) {\n      options.pathSeparator = defaultPathSeparator;\n    }\n    if (options.optCharRegEx == null) {\n      options.optCharRegEx = null;\n    }\n    if (options.wrap == null) {\n      options.wrap = null;\n    }\n    if (options.preparedQuery == null) {\n      options.preparedQuery = preparedQueryCache && preparedQueryCache.query === query ? preparedQueryCache : (preparedQueryCache = new Query(query, options));\n    }\n    return options;\n  };\n\n}).call(this);\n","var $export = require('./_export');\nvar defined = require('./_defined');\nvar fails = require('./_fails');\nvar spaces = require('./_string-ws');\nvar space = '[' + spaces + ']';\nvar non = '\\u200b\\u0085';\nvar ltrim = RegExp('^' + space + space + '*');\nvar rtrim = RegExp(space + space + '*$');\n\nvar exporter = function (KEY, exec, ALIAS) {\n  var exp = {};\n  var FORCE = fails(function () {\n    return !!spaces[KEY]() || non[KEY]() != non;\n  });\n  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];\n  if (ALIAS) exp[ALIAS] = fn;\n  $export($export.P + $export.F * FORCE, 'String', exp);\n};\n\n// 1 -> String#trimLeft\n// 2 -> String#trimRight\n// 3 -> String#trim\nvar trim = exporter.trim = function (string, TYPE) {\n  string = String(defined(string));\n  if (TYPE & 1) string = string.replace(ltrim, '');\n  if (TYPE & 2) string = string.replace(rtrim, '');\n  return string;\n};\n\nmodule.exports = exporter;\n","(function() {\n  var AcronymResult, computeScore, emptyAcronymResult, isAcronymFullWord, isMatch, isSeparator, isWordEnd, isWordStart, miss_coeff, pos_bonus, scoreAcronyms, scoreCharacter, scoreConsecutives, scoreExact, scoreExactMatch, scorePattern, scorePosition, scoreSize, tau_size, wm;\n\n  wm = 150;\n\n  pos_bonus = 20;\n\n  tau_size = 150;\n\n  miss_coeff = 0.75;\n\n  exports.score = function(string, query, options) {\n    var allowErrors, preparedQuery, score, string_lw;\n    preparedQuery = options.preparedQuery, allowErrors = options.allowErrors;\n    if (!(allowErrors || isMatch(string, preparedQuery.core_lw, preparedQuery.core_up))) {\n      return 0;\n    }\n    string_lw = string.toLowerCase();\n    score = computeScore(string, string_lw, preparedQuery);\n    return Math.ceil(score);\n  };\n\n  exports.isMatch = isMatch = function(subject, query_lw, query_up) {\n    var i, j, m, n, qj_lw, qj_up, si;\n    m = subject.length;\n    n = query_lw.length;\n    if (!m || n > m) {\n      return false;\n    }\n    i = -1;\n    j = -1;\n    while (++j < n) {\n      qj_lw = query_lw.charCodeAt(j);\n      qj_up = query_up.charCodeAt(j);\n      while (++i < m) {\n        si = subject.charCodeAt(i);\n        if (si === qj_lw || si === qj_up) {\n          break;\n        }\n      }\n      if (i === m) {\n        return false;\n      }\n    }\n    return true;\n  };\n\n  exports.computeScore = computeScore = function(subject, subject_lw, preparedQuery) {\n    var acro, acro_score, align, csc_diag, csc_row, csc_score, csc_should_rebuild, i, j, m, miss_budget, miss_left, n, pos, query, query_lw, record_miss, score, score_diag, score_row, score_up, si_lw, start, sz;\n    query = preparedQuery.query;\n    query_lw = preparedQuery.query_lw;\n    m = subject.length;\n    n = query.length;\n    acro = scoreAcronyms(subject, subject_lw, query, query_lw);\n    acro_score = acro.score;\n    if (acro.count === n) {\n      return scoreExact(n, m, acro_score, acro.pos);\n    }\n    pos = subject_lw.indexOf(query_lw);\n    if (pos > -1) {\n      return scoreExactMatch(subject, subject_lw, query, query_lw, pos, n, m);\n    }\n    score_row = new Array(n);\n    csc_row = new Array(n);\n    sz = scoreSize(n, m);\n    miss_budget = Math.ceil(miss_coeff * n) + 5;\n    miss_left = miss_budget;\n    csc_should_rebuild = true;\n    j = -1;\n    while (++j < n) {\n      score_row[j] = 0;\n      csc_row[j] = 0;\n    }\n    i = -1;\n    while (++i < m) {\n      si_lw = subject_lw[i];\n      if (!si_lw.charCodeAt(0) in preparedQuery.charCodes) {\n        if (csc_should_rebuild) {\n          j = -1;\n          while (++j < n) {\n            csc_row[j] = 0;\n          }\n          csc_should_rebuild = false;\n        }\n        continue;\n      }\n      score = 0;\n      score_diag = 0;\n      csc_diag = 0;\n      record_miss = true;\n      csc_should_rebuild = true;\n      j = -1;\n      while (++j < n) {\n        score_up = score_row[j];\n        if (score_up > score) {\n          score = score_up;\n        }\n        csc_score = 0;\n        if (query_lw[j] === si_lw) {\n          start = isWordStart(i, subject, subject_lw);\n          csc_score = csc_diag > 0 ? csc_diag : scoreConsecutives(subject, subject_lw, query, query_lw, i, j, start);\n          align = score_diag + scoreCharacter(i, j, start, acro_score, csc_score);\n          if (align > score) {\n            score = align;\n            miss_left = miss_budget;\n          } else {\n            if (record_miss && --miss_left <= 0) {\n              return Math.max(score, score_row[n - 1]) * sz;\n            }\n            record_miss = false;\n          }\n        }\n        score_diag = score_up;\n        csc_diag = csc_row[j];\n        csc_row[j] = csc_score;\n        score_row[j] = score;\n      }\n    }\n    score = score_row[n - 1];\n    return score * sz;\n  };\n\n  exports.isWordStart = isWordStart = function(pos, subject, subject_lw) {\n    var curr_s, prev_s;\n    if (pos === 0) {\n      return true;\n    }\n    curr_s = subject[pos];\n    prev_s = subject[pos - 1];\n    return isSeparator(prev_s) || (curr_s !== subject_lw[pos] && prev_s === subject_lw[pos - 1]);\n  };\n\n  exports.isWordEnd = isWordEnd = function(pos, subject, subject_lw, len) {\n    var curr_s, next_s;\n    if (pos === len - 1) {\n      return true;\n    }\n    curr_s = subject[pos];\n    next_s = subject[pos + 1];\n    return isSeparator(next_s) || (curr_s === subject_lw[pos] && next_s !== subject_lw[pos + 1]);\n  };\n\n  isSeparator = function(c) {\n    return c === ' ' || c === '.' || c === '-' || c === '_' || c === '/' || c === '\\\\';\n  };\n\n  scorePosition = function(pos) {\n    var sc;\n    if (pos < pos_bonus) {\n      sc = pos_bonus - pos;\n      return 100 + sc * sc;\n    } else {\n      return Math.max(100 + pos_bonus - pos, 0);\n    }\n  };\n\n  exports.scoreSize = scoreSize = function(n, m) {\n    return tau_size / (tau_size + Math.abs(m - n));\n  };\n\n  scoreExact = function(n, m, quality, pos) {\n    return 2 * n * (wm * quality + scorePosition(pos)) * scoreSize(n, m);\n  };\n\n  exports.scorePattern = scorePattern = function(count, len, sameCase, start, end) {\n    var bonus, sz;\n    sz = count;\n    bonus = 6;\n    if (sameCase === count) {\n      bonus += 2;\n    }\n    if (start) {\n      bonus += 3;\n    }\n    if (end) {\n      bonus += 1;\n    }\n    if (count === len) {\n      if (start) {\n        if (sameCase === len) {\n          sz += 2;\n        } else {\n          sz += 1;\n        }\n      }\n      if (end) {\n        bonus += 1;\n      }\n    }\n    return sameCase + sz * (sz + bonus);\n  };\n\n  exports.scoreCharacter = scoreCharacter = function(i, j, start, acro_score, csc_score) {\n    var posBonus;\n    posBonus = scorePosition(i);\n    if (start) {\n      return posBonus + wm * ((acro_score > csc_score ? acro_score : csc_score) + 10);\n    }\n    return posBonus + wm * csc_score;\n  };\n\n  exports.scoreConsecutives = scoreConsecutives = function(subject, subject_lw, query, query_lw, i, j, startOfWord) {\n    var k, m, mi, n, nj, sameCase, sz;\n    m = subject.length;\n    n = query.length;\n    mi = m - i;\n    nj = n - j;\n    k = mi < nj ? mi : nj;\n    sameCase = 0;\n    sz = 0;\n    if (query[j] === subject[i]) {\n      sameCase++;\n    }\n    while (++sz < k && query_lw[++j] === subject_lw[++i]) {\n      if (query[j] === subject[i]) {\n        sameCase++;\n      }\n    }\n    if (sz < k) {\n      i--;\n    }\n    if (sz === 1) {\n      return 1 + 2 * sameCase;\n    }\n    return scorePattern(sz, n, sameCase, startOfWord, isWordEnd(i, subject, subject_lw, m));\n  };\n\n  exports.scoreExactMatch = scoreExactMatch = function(subject, subject_lw, query, query_lw, pos, n, m) {\n    var end, i, pos2, sameCase, start;\n    start = isWordStart(pos, subject, subject_lw);\n    if (!start) {\n      pos2 = subject_lw.indexOf(query_lw, pos + 1);\n      if (pos2 > -1) {\n        start = isWordStart(pos2, subject, subject_lw);\n        if (start) {\n          pos = pos2;\n        }\n      }\n    }\n    i = -1;\n    sameCase = 0;\n    while (++i < n) {\n      if (query[pos + i] === subject[i]) {\n        sameCase++;\n      }\n    }\n    end = isWordEnd(pos + n - 1, subject, subject_lw, m);\n    return scoreExact(n, m, scorePattern(n, n, sameCase, start, end), pos);\n  };\n\n  AcronymResult = (function() {\n    function AcronymResult(score, pos, count) {\n      this.score = score;\n      this.pos = pos;\n      this.count = count;\n    }\n\n    return AcronymResult;\n\n  })();\n\n  emptyAcronymResult = new AcronymResult(0, 0.1, 0);\n\n  exports.scoreAcronyms = scoreAcronyms = function(subject, subject_lw, query, query_lw) {\n    var count, fullWord, i, j, m, n, qj_lw, sameCase, score, sepCount, sumPos;\n    m = subject.length;\n    n = query.length;\n    if (!(m > 1 && n > 1)) {\n      return emptyAcronymResult;\n    }\n    count = 0;\n    sepCount = 0;\n    sumPos = 0;\n    sameCase = 0;\n    i = -1;\n    j = -1;\n    while (++j < n) {\n      qj_lw = query_lw[j];\n      if (isSeparator(qj_lw)) {\n        i = subject_lw.indexOf(qj_lw, i + 1);\n        if (i > -1) {\n          sepCount++;\n          continue;\n        } else {\n          break;\n        }\n      }\n      while (++i < m) {\n        if (qj_lw === subject_lw[i] && isWordStart(i, subject, subject_lw)) {\n          if (query[j] === subject[i]) {\n            sameCase++;\n          }\n          sumPos += i;\n          count++;\n          break;\n        }\n      }\n      if (i === m) {\n        break;\n      }\n    }\n    if (count < 2) {\n      return emptyAcronymResult;\n    }\n    fullWord = count === n ? isAcronymFullWord(subject, subject_lw, query, count) : false;\n    score = scorePattern(count, n, sameCase, true, fullWord);\n    return new AcronymResult(score, sumPos / count, count + sepCount);\n  };\n\n  isAcronymFullWord = function(subject, subject_lw, query, nbAcronymInQuery) {\n    var count, i, m, n;\n    m = subject.length;\n    n = query.length;\n    count = 0;\n    if (m > 12 * n) {\n      return false;\n    }\n    i = -1;\n    while (++i < m) {\n      if (isWordStart(i, subject, subject_lw) && ++count > nbAcronymInQuery) {\n        return false;\n      }\n    }\n    return true;\n  };\n\n}).call(this);\n","module.exports = '\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003' +\n  '\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF';\n","(function() {\n  var computeScore, countDir, file_coeff, getExtension, getExtensionScore, isMatch, scorePath, scoreSize, tau_depth, _ref;\n\n  _ref = require('./scorer'), isMatch = _ref.isMatch, computeScore = _ref.computeScore, scoreSize = _ref.scoreSize;\n\n  tau_depth = 20;\n\n  file_coeff = 2.5;\n\n  exports.score = function(string, query, options) {\n    var allowErrors, preparedQuery, score, string_lw;\n    preparedQuery = options.preparedQuery, allowErrors = options.allowErrors;\n    if (!(allowErrors || isMatch(string, preparedQuery.core_lw, preparedQuery.core_up))) {\n      return 0;\n    }\n    string_lw = string.toLowerCase();\n    score = computeScore(string, string_lw, preparedQuery);\n    score = scorePath(string, string_lw, score, options);\n    return Math.ceil(score);\n  };\n\n  scorePath = function(subject, subject_lw, fullPathScore, options) {\n    var alpha, basePathScore, basePos, depth, end, extAdjust, fileLength, pathSeparator, preparedQuery, useExtensionBonus;\n    if (fullPathScore === 0) {\n      return 0;\n    }\n    preparedQuery = options.preparedQuery, useExtensionBonus = options.useExtensionBonus, pathSeparator = options.pathSeparator;\n    end = subject.length - 1;\n    while (subject[end] === pathSeparator) {\n      end--;\n    }\n    basePos = subject.lastIndexOf(pathSeparator, end);\n    fileLength = end - basePos;\n    extAdjust = 1.0;\n    if (useExtensionBonus) {\n      extAdjust += getExtensionScore(subject_lw, preparedQuery.ext, basePos, end, 2);\n      fullPathScore *= extAdjust;\n    }\n    if (basePos === -1) {\n      return fullPathScore;\n    }\n    depth = preparedQuery.depth;\n    while (basePos > -1 && depth-- > 0) {\n      basePos = subject.lastIndexOf(pathSeparator, basePos - 1);\n    }\n    basePathScore = basePos === -1 ? fullPathScore : extAdjust * computeScore(subject.slice(basePos + 1, end + 1), subject_lw.slice(basePos + 1, end + 1), preparedQuery);\n    alpha = 0.5 * tau_depth / (tau_depth + countDir(subject, end + 1, pathSeparator));\n    return alpha * basePathScore + (1 - alpha) * fullPathScore * scoreSize(0, file_coeff * fileLength);\n  };\n\n  exports.countDir = countDir = function(path, end, pathSeparator) {\n    var count, i;\n    if (end < 1) {\n      return 0;\n    }\n    count = 0;\n    i = -1;\n    while (++i < end && path[i] === pathSeparator) {\n      continue;\n    }\n    while (++i < end) {\n      if (path[i] === pathSeparator) {\n        count++;\n        while (++i < end && path[i] === pathSeparator) {\n          continue;\n        }\n      }\n    }\n    return count;\n  };\n\n  exports.getExtension = getExtension = function(str) {\n    var pos;\n    pos = str.lastIndexOf(\".\");\n    if (pos < 0) {\n      return \"\";\n    } else {\n      return str.substr(pos + 1);\n    }\n  };\n\n  getExtensionScore = function(candidate, ext, startPos, endPos, maxDepth) {\n    var m, matched, n, pos;\n    if (!ext.length) {\n      return 0;\n    }\n    pos = candidate.lastIndexOf(\".\", endPos);\n    if (!(pos > startPos)) {\n      return 0;\n    }\n    n = ext.length;\n    m = endPos - pos;\n    if (m < n) {\n      n = m;\n      m = ext.length;\n    }\n    pos++;\n    matched = -1;\n    while (++matched < n) {\n      if (candidate[pos + matched] !== ext[matched]) {\n        break;\n      }\n    }\n    if (matched === 0 && maxDepth > 0) {\n      return 0.9 * getExtensionScore(candidate, ext, startPos, pos - 2, maxDepth - 1);\n    }\n    return matched / m;\n  };\n\n}).call(this);\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","(function() {\n  var Query, coreChars, countDir, getCharCodes, getExtension, opt_char_re, truncatedUpperCase, _ref;\n\n  _ref = require(\"./pathScorer\"), countDir = _ref.countDir, getExtension = _ref.getExtension;\n\n  module.exports = Query = (function() {\n    function Query(query, _arg) {\n      var optCharRegEx, pathSeparator, _ref1;\n      _ref1 = _arg != null ? _arg : {}, optCharRegEx = _ref1.optCharRegEx, pathSeparator = _ref1.pathSeparator;\n      if (!(query && query.length)) {\n        return null;\n      }\n      this.query = query;\n      this.query_lw = query.toLowerCase();\n      this.core = coreChars(query, optCharRegEx);\n      this.core_lw = this.core.toLowerCase();\n      this.core_up = truncatedUpperCase(this.core);\n      this.depth = countDir(query, query.length, pathSeparator);\n      this.ext = getExtension(this.query_lw);\n      this.charCodes = getCharCodes(this.query_lw);\n    }\n\n    return Query;\n\n  })();\n\n  opt_char_re = /[ _\\-:\\/\\\\]/g;\n\n  coreChars = function(query, optCharRegEx) {\n    if (optCharRegEx == null) {\n      optCharRegEx = opt_char_re;\n    }\n    return query.replace(optCharRegEx, '');\n  };\n\n  truncatedUpperCase = function(str) {\n    var char, upper, _i, _len;\n    upper = \"\";\n    for (_i = 0, _len = str.length; _i < _len; _i++) {\n      char = str[_i];\n      upper += char.toUpperCase()[0];\n    }\n    return upper;\n  };\n\n  getCharCodes = function(str) {\n    var charCodes, i, len;\n    len = str.length;\n    i = -1;\n    charCodes = [];\n    while (++i < len) {\n      charCodes[str.charCodeAt(i)] = true;\n    }\n    return charCodes;\n  };\n\n}).call(this);\n","(function() {\n  var Query, pathScorer, pluckCandidates, scorer, sortCandidates;\n\n  scorer = require('./scorer');\n\n  pathScorer = require('./pathScorer');\n\n  Query = require('./query');\n\n  pluckCandidates = function(a) {\n    return a.candidate;\n  };\n\n  sortCandidates = function(a, b) {\n    return b.score - a.score;\n  };\n\n  module.exports = function(candidates, query, options) {\n    var bKey, candidate, key, maxInners, maxResults, score, scoreProvider, scoredCandidates, spotLeft, string, usePathScoring, _i, _len;\n    scoredCandidates = [];\n    key = options.key, maxResults = options.maxResults, maxInners = options.maxInners, usePathScoring = options.usePathScoring;\n    spotLeft = (maxInners != null) && maxInners > 0 ? maxInners : candidates.length + 1;\n    bKey = key != null;\n    scoreProvider = usePathScoring ? pathScorer : scorer;\n    for (_i = 0, _len = candidates.length; _i < _len; _i++) {\n      candidate = candidates[_i];\n      string = bKey ? candidate[key] : candidate;\n      if (!string) {\n        continue;\n      }\n      score = scoreProvider.score(string, query, options);\n      if (score > 0) {\n        scoredCandidates.push({\n          candidate: candidate,\n          score: score\n        });\n        if (!--spotLeft) {\n          break;\n        }\n      }\n    }\n    scoredCandidates.sort(sortCandidates);\n    candidates = scoredCandidates.map(pluckCandidates);\n    if (maxResults != null) {\n      candidates = candidates.slice(0, maxResults);\n    }\n    return candidates;\n  };\n\n}).call(this);\n","(function() {\n  var basenameMatch, computeMatch, isMatch, isWordStart, match, mergeMatches, scoreAcronyms, scoreCharacter, scoreConsecutives, _ref;\n\n  _ref = require('./scorer'), isMatch = _ref.isMatch, isWordStart = _ref.isWordStart, scoreConsecutives = _ref.scoreConsecutives, scoreCharacter = _ref.scoreCharacter, scoreAcronyms = _ref.scoreAcronyms;\n\n  exports.match = match = function(string, query, options) {\n    var allowErrors, baseMatches, matches, pathSeparator, preparedQuery, string_lw;\n    allowErrors = options.allowErrors, preparedQuery = options.preparedQuery, pathSeparator = options.pathSeparator;\n    if (!(allowErrors || isMatch(string, preparedQuery.core_lw, preparedQuery.core_up))) {\n      return [];\n    }\n    string_lw = string.toLowerCase();\n    matches = computeMatch(string, string_lw, preparedQuery);\n    if (matches.length === 0) {\n      return matches;\n    }\n    if (string.indexOf(pathSeparator) > -1) {\n      baseMatches = basenameMatch(string, string_lw, preparedQuery, pathSeparator);\n      matches = mergeMatches(matches, baseMatches);\n    }\n    return matches;\n  };\n\n  exports.wrap = function(string, query, options) {\n    var matchIndex, matchPos, matchPositions, output, strPos, tagClass, tagClose, tagOpen, _ref1;\n    if ((options.wrap != null)) {\n      _ref1 = options.wrap, tagClass = _ref1.tagClass, tagOpen = _ref1.tagOpen, tagClose = _ref1.tagClose;\n    }\n    if (tagClass == null) {\n      tagClass = 'highlight';\n    }\n    if (tagOpen == null) {\n      tagOpen = '<strong class=\"' + tagClass + '\">';\n    }\n    if (tagClose == null) {\n      tagClose = '</strong>';\n    }\n    if (string === query) {\n      return tagOpen + string + tagClose;\n    }\n    matchPositions = match(string, query, options);\n    if (matchPositions.length === 0) {\n      return string;\n    }\n    output = '';\n    matchIndex = -1;\n    strPos = 0;\n    while (++matchIndex < matchPositions.length) {\n      matchPos = matchPositions[matchIndex];\n      if (matchPos > strPos) {\n        output += string.substring(strPos, matchPos);\n        strPos = matchPos;\n      }\n      while (++matchIndex < matchPositions.length) {\n        if (matchPositions[matchIndex] === matchPos + 1) {\n          matchPos++;\n        } else {\n          matchIndex--;\n          break;\n        }\n      }\n      matchPos++;\n      if (matchPos > strPos) {\n        output += tagOpen;\n        output += string.substring(strPos, matchPos);\n        output += tagClose;\n        strPos = matchPos;\n      }\n    }\n    if (strPos <= string.length - 1) {\n      output += string.substring(strPos);\n    }\n    return output;\n  };\n\n  basenameMatch = function(subject, subject_lw, preparedQuery, pathSeparator) {\n    var basePos, depth, end;\n    end = subject.length - 1;\n    while (subject[end] === pathSeparator) {\n      end--;\n    }\n    basePos = subject.lastIndexOf(pathSeparator, end);\n    if (basePos === -1) {\n      return [];\n    }\n    depth = preparedQuery.depth;\n    while (depth-- > 0) {\n      basePos = subject.lastIndexOf(pathSeparator, basePos - 1);\n      if (basePos === -1) {\n        return [];\n      }\n    }\n    basePos++;\n    end++;\n    return computeMatch(subject.slice(basePos, end), subject_lw.slice(basePos, end), preparedQuery, basePos);\n  };\n\n  mergeMatches = function(a, b) {\n    var ai, bj, i, j, m, n, out;\n    m = a.length;\n    n = b.length;\n    if (n === 0) {\n      return a.slice();\n    }\n    if (m === 0) {\n      return b.slice();\n    }\n    i = -1;\n    j = 0;\n    bj = b[j];\n    out = [];\n    while (++i < m) {\n      ai = a[i];\n      while (bj <= ai && ++j < n) {\n        if (bj < ai) {\n          out.push(bj);\n        }\n        bj = b[j];\n      }\n      out.push(ai);\n    }\n    while (j < n) {\n      out.push(b[j++]);\n    }\n    return out;\n  };\n\n  computeMatch = function(subject, subject_lw, preparedQuery, offset) {\n    var DIAGONAL, LEFT, STOP, UP, acro_score, align, backtrack, csc_diag, csc_row, csc_score, i, j, m, matches, move, n, pos, query, query_lw, score, score_diag, score_row, score_up, si_lw, start, trace;\n    if (offset == null) {\n      offset = 0;\n    }\n    query = preparedQuery.query;\n    query_lw = preparedQuery.query_lw;\n    m = subject.length;\n    n = query.length;\n    acro_score = scoreAcronyms(subject, subject_lw, query, query_lw).score;\n    score_row = new Array(n);\n    csc_row = new Array(n);\n    STOP = 0;\n    UP = 1;\n    LEFT = 2;\n    DIAGONAL = 3;\n    trace = new Array(m * n);\n    pos = -1;\n    j = -1;\n    while (++j < n) {\n      score_row[j] = 0;\n      csc_row[j] = 0;\n    }\n    i = -1;\n    while (++i < m) {\n      score = 0;\n      score_up = 0;\n      csc_diag = 0;\n      si_lw = subject_lw[i];\n      j = -1;\n      while (++j < n) {\n        csc_score = 0;\n        align = 0;\n        score_diag = score_up;\n        if (query_lw[j] === si_lw) {\n          start = isWordStart(i, subject, subject_lw);\n          csc_score = csc_diag > 0 ? csc_diag : scoreConsecutives(subject, subject_lw, query, query_lw, i, j, start);\n          align = score_diag + scoreCharacter(i, j, start, acro_score, csc_score);\n        }\n        score_up = score_row[j];\n        csc_diag = csc_row[j];\n        if (score > score_up) {\n          move = LEFT;\n        } else {\n          score = score_up;\n          move = UP;\n        }\n        if (align > score) {\n          score = align;\n          move = DIAGONAL;\n        } else {\n          csc_score = 0;\n        }\n        score_row[j] = score;\n        csc_row[j] = csc_score;\n        trace[++pos] = score > 0 ? move : STOP;\n      }\n    }\n    i = m - 1;\n    j = n - 1;\n    pos = i * n + j;\n    backtrack = true;\n    matches = [];\n    while (backtrack && i >= 0 && j >= 0) {\n      switch (trace[pos]) {\n        case UP:\n          i--;\n          pos -= n;\n          break;\n        case LEFT:\n          j--;\n          pos--;\n          break;\n        case DIAGONAL:\n          matches.push(i + offset);\n          j--;\n          i--;\n          pos -= n + 1;\n          break;\n        default:\n          backtrack = false;\n      }\n    }\n    matches.reverse();\n    return matches;\n  };\n\n}).call(this);\n"],"sourceRoot":""}